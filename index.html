<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schichtplan-Generator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        h1, h2, h3 {
            color: #0056b3;
        }
        .container, .start-screen {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        .start-screen {
            max-width: 500px;
            margin: 40px auto;
            text-align: center;
        }
        .input-group {
            margin-bottom: 15px;
        }
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .input-group input[type="text"],
        .input-group textarea,
        .input-group select,
        .input-group input[type="number"] {
            width: calc(100% - 22px);
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .input-group button, .start-screen button {
            background-color: #007bff;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
        }
        .input-group button:hover, .start-screen button:hover {
            background-color: #0056b3;
        }
        .list-display {
            margin-top: 10px;
            border: 1px solid #eee;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 4px;
            min-height: 50px;
        }
        .list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px dashed #eee;
            cursor: grab;
            background-color: #fff;
            margin-bottom: 2px;
        }
        .list-item:last-child { border-bottom: none; }
        .list-item.dragging { opacity: 0.5; border: 2px dashed #007bff; }
        .list-item.drag-over { border-top: 2px solid #007bff; }
        .list-item.drag-over-bottom { border-bottom: 2px solid #007bff; }
        .remove-btn {
            background-color: #dc3545; color: white; border: none; border-radius: 50%;
            width: 20px; height: 20px; font-size: 12px; cursor: pointer;
            display: flex; justify-content: center; align-items: center;
            line-height: 1; padding: 0; margin-left: 10px;
        }
        .remove-btn:hover { background-color: #c82333; }
        .assign-section {
            display: grid; grid-template-columns: 1fr 1fr;
            gap: 20px; margin-top: 20px;
        }
        .assign-section select {
            width: 100%; padding: 8px; margin-bottom: 10px;
            border: 1px solid #ddd; border-radius: 4px;
        }
        .assign-section .skill-assign-box {
            border: 1px solid #ccc; padding: 15px; border-radius: 8px; background-color: #fdfdfd;
        }
        .assign-section .skill-assign-box h3 { margin-top: 0; color: #007bff; }
        #scheduleOutput { margin-top: 30px; border-top: 2px solid #007bff; padding-top: 20px; }
        .schedule-table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        .schedule-table th, .schedule-table td { border: 1px solid #ddd; padding: 10px; text-align: left; }
        .schedule-table th { background-color: #e2f0ff; color: #0056b3; }
        .schedule-table td { background-color: #fff; }
        .error-message { color: red; font-weight: bold; margin-top: 10px; }
        .info-message { color: green; font-weight: bold; margin-top: 10px; }
        .present-employees-box {
            border: 1px solid #ccc; padding: 15px; border-radius: 8px;
            background-color: #fdfdfd; margin-top: 20px;
        }
        .present-employees-box h3 { margin-top: 0; color: #007bff; }
        .present-employees-box .checkbox-group label { display: block; margin-bottom: 5px; }
        .present-employees-box .checkbox-group input[type="checkbox"]:disabled + span,
        .present-employees-box .checkbox-group input[type="checkbox"]:disabled {
            color: #999; cursor: not-allowed; opacity: 0.6;
        }
        .print-button {
            background-color: #28a745; color: white; padding: 10px 20px;
            border: none; border-radius: 4px; cursor: pointer;
            font-size: 16px; margin-top: 20px;
        }
        .print-button:hover { background-color: #218838; }
        #selectedEmployeeCount { font-weight: bold; margin-top: 10px; color: #0056b3; }
        .schedule-table td.error-duplicate { background-color: #ff6666 !important; }
        .schedule-table td.warn-skill { background-color: #ffaa00 !important; }
        .schedule-table td.warn-unknown { background-color: #a0a0a0 !important; }
        .schedule-table td.auto-compromise { background-color: #ffddaa !important; }
        .overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7); z-index: 1000;
            justify-content: center; align-items: center;
        }
        .overlay-content {
            background-color: #fff; padding: 30px; border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3); width: 90%;
            max-width: 700px; max-height: 90vh; overflow-y: auto; position: relative;
        }
        .close-btn {
            position: absolute; top: 10px; right: 10px; font-size: 24px;
            cursor: pointer; color: #555;
        }
        .close-btn:hover { color: #000; }
        .login-form { display: flex; flex-direction: column; gap: 10px; margin-top: 20px; }
        .login-form input { padding: 10px; border: 1px solid #ddd; border-radius: 4px; }
        .login-form button {
            padding: 10px 15px; background-color: #007bff; color: white;
            border: none; border-radius: 4px; cursor: pointer;
        }
        .login-form button:hover { background-color: #0056b3; }
        #adminMenuContent select {
            width: calc(100% - 2px); padding: 8px; margin-bottom: 10px;
            border: 1px solid #ddd; border-radius: 4px;
        }
        #adminMenuContent .list-display {
            margin-top: 10px; border: 1px solid #eee; padding: 10px;
            background-color: #f9f9f9; border-radius: 4px; min-height: 50px;
        }
        #adminMenuContent .list-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 5px 0; border-bottom: 1px dashed #eee;
        }
        #adminMenuContent .list-item:last-child { border-bottom: none; }
        #adminMenuContent .remove-btn-small {
            background-color: #dc3545; color: white; border: none; border-radius: 50%;
            width: 20px; height: 20px; font-size: 12px; cursor: pointer;
            display: flex; justify-content: center; align-items: center;
            line-height: 1; padding: 0; margin-left: 10px;
        }
        .admin-section { margin-top: 25px; padding-top: 15px; border-top: 1px solid #eee; }
        .admin-section h3 { color: #007bff; margin-top: 0; }
        .admin-section .input-group { margin-bottom: 10px; }
        .admin-section .input-group button { margin-top: 5px; }
        .employee-pair-item span { flex-grow: 1; }
        .employee-pair-item select { width: auto; margin-left: 10px; margin-right: 10px; }
        .admin-button-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .admin-button-container .left-buttons {
            display: flex;
            gap: 10px;
        }
        .admin-access-button {
            background-color: #6c757d; color: white; padding: 12px 25px;
            border: none; border-radius: 4px; cursor: pointer; font-size: 18px;
            font-weight: bold; transition: background-color 0.2s ease;
        }
        .admin-access-button:hover { background-color: #5a6268; }
        .page-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>

    <div id="startScreen" class="start-screen">
        <h1>Willkommen!</h1>
        <p>Bitte wähle deine Gruppe und Schicht aus, um fortzufahren.</p>
        <div class="input-group">
            <label for="groupInput">Gruppen-ID (z. B. MA3210)</label>
            <input type="text" id="groupInput" placeholder="MA_ _ _ _">
        </div>
        <div class="input-group">
            <label for="shiftSelect">Schicht</label>
            <select id="shiftSelect">
                <option value="Schicht 1">Schicht 1</option>
                <option value="Schicht 2">Schicht 2</option>
                <option value="DNS">DNS</option>
            </select>
        </div>
        <button onclick="startApp()">Starten</button>
        <div id="startErrorMessage" class="error-message"></div>
    </div>

    <div id="appContainer" class="container" style="display: none;">
        <div class="page-header">
            <h1 style="margin: 0;">Schichtplan Generator</h1>
            <div id="sessionInfo" style="text-align: right;">
                <h3 style="margin: 0;" id="headerGroup"></h3>
                <h3 style="margin: 0;" id="headerShift"></h3>
            </div>
        </div>
        
        <div class="admin-button-container">
            <div class="left-buttons">
                <button class="admin-access-button" onclick="exportToJSON()">Daten exportieren</button>
                <input type="file" id="importJSONFile" accept=".json" style="display:none" onchange="importFromJSON(event)">
                <button class="admin-access-button" onclick="document.getElementById('importJSONFile').click()">Daten importieren</button>
            </div>
            <button class="admin-access-button" onclick="openAdminLogin()">Login</button>
        </div>
        
        <p>Erfasse deine Mitarbeiter, Arbeitsplätze und deren Fähigkeiten, um einen täglichen Schichtplan zu erstellen.</p>

        <h2>1. Mitarbeiter erfassen</h2>
        <div class="input-group">
            <label for="employeeName">Mitarbeitername:</label>
            <input type="text" id="employeeName" placeholder="Max Mustermann">
            <button onclick="addEmployee()">Mitarbeiter hinzufügen</button>
        </div>
        <div class="list-display" id="employeeList"></div>

        <h2>2. Arbeitsplätze erfassen</h2>
        <div class="input-group">
            <label for="workplaceName">Arbeitsplatzbezeichnung:</label>
            <input type="text" id="workplaceName" placeholder="Montage Station A">
            <button onclick="addWorkplace()">Arbeitsplatz hinzufügen</button>
        </div>
        <div class="list-display" id="workplaceList"></div>

        <h2>3. Mitarbeiter-Fähigkeiten zuweisen</h2>
        <p>Wähle einen Mitarbeiter und die Arbeitsplätze aus, die er beherrscht.</p>
        <div class="assign-section">
            <div class="skill-assign-box">
                <h3>Mitarbeiter auswählen</h3>
                <select id="selectEmployeeForSkills" onchange="displayEmployeeSkills()"></select>
            </div>
            <div class="skill-assign-box">
                <h3>Beherrschte Arbeitsplätze</h3>
                <p>Halte die STRG/CMD-Taste gedrückt, um mehrere Arbeitsplätze auszuwählen.</p>
                <select id="selectWorkplacesForSkills" multiple size="8"></select>
                <button onclick="assignSkills()">Fähigkeiten zuweisen</button>
                <div class="list-display" id="currentEmployeeSkills"></div>
            </div>
        </div>

        <h2>4. Schichtplan erstellen</h2>
        <div class="input-group">
            <label for="dayOfWeek">Tag auswählen:</label>
            <select id="dayOfWeek">
                <option value="Montag">Montag</option>
                <option value="Dienstag">Dienstag</option>
                <option value="Mittwoch">Mittwoch</option>
                <option value="Donnerstag">Donnerstag</option>
                <option value="Freitag">Freitag</option>
                <option value="Samstag">Samstag</option>
            </select>
        </div>

        <div class="input-group">
            <label for="maxWorkplaceRepeats">Max. Wiederholungen pro Mitarbeiter & Arbeitsplatz pro Tag:</label>
            <input type="number" id="maxWorkplaceRepeats" value="1" min="1" max="4">
            <small>Bestimmt, wie oft ein Mitarbeiter maximal denselben Arbeitsplatz am Tag besetzen darf. Höhere Werte erhöhen die Flexibilität, aber auch die Doppelbelegung.</small>
        </div>

        <div class="present-employees-box"> 
            <h3>Mitarbeiter, die an diesem Tag arbeiten</h3> 
            <p>Wählen Sie die Mitarbeiter aus, die für den ausgewählten Tag eingeplant werden sollen.</p> 
            <div id="presentEmployeesCheckboxes" class="checkbox-group"></div>
            <div id="selectedEmployeeCount"></div>
        </div>
        <div class="input-group">
            <button onclick="generateSchedule()">Schichtplan erstellen</button>
        </div>

        <div id="scheduleOutput"></div>
        <button id="printScheduleBtn" class="print-button" style="display:none;" onclick="printSchedule()">Schichtplan drucken / als PDF speichern</button>
        <div id="errorMessage" class="error-message"></div>
        <div id="infoMessage" class="info-message"></div>
    </div>

    <div id="adminOverlay" class="overlay">
        <div class="overlay-content">
            <span class="close-btn" onclick="closeAdminMenu()">&times;</span>
            <div id="adminLogin">
                <h2>Login</h2>
                <div class="login-form">
                    <input type="text" id="adminUsername" placeholder="Benutzername">
                    <input type="password" id="adminPassword" placeholder="Passwort">
                    <button onclick="loginAdmin()">Login</button>
                    <div id="adminLoginMessage" class="error-message"></div>
                </div>
            </div>

            <div id="adminMenuContent" style="display:none;">
                <h2>Admin-Einstellungen</h2>
                <div class="admin-section">
                    <h3>Arbeitsplatz-Verknüpfungen verwalten</h3>
                    <p>Wähle zwei Arbeitsplätze aus, die immer zusammen besetzt werden sollen.</p>
                    <div class="input-group">
                        <label for="selectWorkplace1">Arbeitsplatz 1:</label>
                        <select id="selectWorkplace1"></select>
                    </div>
                    <div class="input-group">
                        <label for="selectWorkplace2">Arbeitsplatz 2:</label>
                        <select id="selectWorkplace2"></select>
                    </div>
                    <button onclick="addWorkplaceLink()">Verknüpfung hinzufügen</button>
                    <div id="linkedWorkplaceMessage" class="error-message"></div>
                    <div class="list-display" id="linkedWorkplacesList"></div>
                </div>

                <div class="admin-section">
                    <h3>Mitarbeiter-Paare verwalten (Gerne zusammen arbeiten)</h3>
                    <p>Wähle zwei Mitarbeiter aus, die gerne zusammenarbeiten.</p>
                    <div class="input-group">
                        <label for="selectEmployee1">Mitarbeiter 1:</label>
                        <select id="selectEmployee1"></select>
                    </div>
                    <div class="input-group">
                        <label for="selectEmployee2">Mitarbeiter 2:</label>
                        <select id="selectEmployee2"></select>
                    </div>
                    <div class="input-group">
                        <label for="maxPairingsPerDay">Max. gemeinsame Runden pro Tag:</label>
                        <select id="maxPairingsPerDay">
                            <option value="1">1 Runde</option>
                            <option value="2">2 Runden</option>
                            <option value="3">3 Runden</option>
                            <option value="4">4 Runden</option>
                        </select>
                    </div>
                    <button onclick="addEmployeePair()">Paar hinzufügen</button>
                    <div id="employeePairMessage" class="error-message"></div>
                    <div class="list-display" id="employeePairsList"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const G_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbxPBEqbokAxppLQukwrrvMHeP55I8CFxLS5npsFLY8fPaG7RhrLHFg6VdxGjY482xFc/exec';

        // Globale Variablen für die aktuelle Sitzung
        let currentGroup = '';
        let currentShift = '';

        let employees = [];
        let workplaces = [];
        let employeeSkills = {};
        let allDailySchedules = {};
        let linkedWorkplaces = [];
        let employeePairs = [];
        let draggedItem = null;

        function startApp() {
            const groupInput = document.getElementById('groupInput').value.trim().toUpperCase();
            const shiftSelect = document.getElementById('shiftSelect').value;
            const startErrorMessage = document.getElementById('startErrorMessage');
            
            const groupRegex = /^MA\d{4}$/;
            if (!groupRegex.test(groupInput)) {
                startErrorMessage.textContent = 'Ungültiges Gruppenformat. Bitte MA gefolgt von 4 Zahlen eingeben (z.B. MA1234).';
                return;
            }

            startErrorMessage.textContent = '';
            currentGroup = groupInput;
            currentShift = shiftSelect;
            
            document.getElementById('headerGroup').textContent = `Gruppe: ${currentGroup}`;
            document.getElementById('headerShift').textContent = `Schicht: ${currentShift}`;
            
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('appContainer').style.display = 'block';
            
            loadData();
        }

        async function saveData() {
            if (!currentGroup || !currentShift) return;

            const dataPayload = {
                employees, workplaces, employeeSkills,
                allDailySchedules, linkedWorkplaces, employeePairs
            };

            displayMessage('Speichere Daten online...', 'info');
            
            const url = `${G_SCRIPT_URL}?group=${currentGroup}&shift=${currentShift}`;

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    mode: 'cors',
                    headers: { 'Content-Type': 'text/plain;charset=utf-8' },
                    body: JSON.stringify(dataPayload)
                });
                const result = await response.json();

                if (result.status === 'success') {
                    displayMessage('Daten erfolgreich online gespeichert!', 'info');
                } else {
                    throw new Error(result.message);
                }
            } catch (error) {
                console.error('Fehler beim Speichern:', error);
                displayMessage(`Fehler beim Speichern der Daten: ${error.message}`, 'error');
            }
        }

        async function loadData() {
            if (!currentGroup || !currentShift) return;

            displayMessage('Lade Daten vom Server...', 'info');
            const url = `${G_SCRIPT_URL}?group=${currentGroup}&shift=${currentShift}`;

            try {
                const response = await fetch(url);
                const data = await response.json();

                if (data && Object.keys(data).length > 0) {
                    employees = data.employees || [];
                    workplaces = data.workplaces || [];
                    employeeSkills = data.employeeSkills || {};
                    allDailySchedules = data.allDailySchedules || {};
                    linkedWorkplaces = data.linkedWorkplaces || [];
                    employeePairs = data.employeePairs || [];
                    displayMessage('Daten erfolgreich geladen.', 'info');
                } else {
                     displayMessage('Keine Daten für diese Gruppe/Schicht gefunden. Es wird ein neuer Datensatz angelegt.', 'info');
                     employees = []; workplaces = []; employeeSkills = {};
                     allDailySchedules = {}; linkedWorkplaces = []; employeePairs = [];
                }
            } catch (error) {
                console.error('Fehler beim Laden der Daten:', error);
                displayMessage(`Konnte keine Daten laden. Eventuell ist es der erste Start für diese Gruppe/Schicht. (${error.message})`, 'error');
                 employees = []; workplaces = []; employeeSkills = {};
                 allDailySchedules = {}; linkedWorkplaces = []; employeePairs = [];
            }
            
            renderEmployeeList();
            renderWorkplaceList();
            updateEmployeeSelects();
            updateWorkplaceSelects();
            updatePresentEmployeeCheckboxes();
            updateLinkedWorkplaceSelects();
            updateEmployeePairSelects();
            renderLinkedWorkplaces();
            renderEmployeePairs();
        }
        
        function openAdminLogin() {
            document.getElementById('adminOverlay').style.display = 'flex';
            document.getElementById('adminLogin').style.display = 'block';
            document.getElementById('adminMenuContent').style.display = 'none';
            document.getElementById('adminUsername').value = '';
            document.getElementById('adminPassword').value = '';
            document.getElementById('adminLoginMessage').textContent = '';
        }

        function closeAdminMenu() {
            document.getElementById('adminOverlay').style.display = 'none';
        }

        function loginAdmin() {
            const username = document.getElementById('adminUsername').value;
            const password = document.getElementById('adminPassword').value;
            const loginMessageDiv = document.getElementById('adminLoginMessage');

            if (username === 'admin' && password === 'admin') {
                document.getElementById('adminLogin').style.display = 'none';
                document.getElementById('adminMenuContent').style.display = 'block';
                updateLinkedWorkplaceSelects();
                renderLinkedWorkplaces();
                updateEmployeePairSelects();
                renderEmployeePairs();
                loginMessageDiv.textContent = '';
            } else {
                loginMessageDiv.textContent = 'Falscher Benutzername oder Passwort.';
            }
        }

        function updateLinkedWorkplaceSelects() {
            const selectWp1 = document.getElementById('selectWorkplace1');
            const selectWp2 = document.getElementById('selectWorkplace2');
            
            selectWp1.innerHTML = '<option value="">-- Arbeitsplatz 1 auswählen --</option>';
            selectWp2.innerHTML = '<option value="">-- Arbeitsplatz 2 auswählen --</option>';

            workplaces.forEach(wp => {
                const option1 = document.createElement('option');
                option1.value = wp;
                option1.textContent = wp;
                selectWp1.appendChild(option1);

                const option2 = document.createElement('option');
                option2.value = wp;
                option2.textContent = wp;
                selectWp2.appendChild(option2);
            });
        }

        function addWorkplaceLink() {
            const wp1 = document.getElementById('selectWorkplace1').value;
            const wp2 = document.getElementById('selectWorkplace2').value;
            const messageDiv = document.getElementById('linkedWorkplaceMessage');
            messageDiv.textContent = ''; 

            if (!wp1 || !wp2) {
                messageDiv.textContent = 'Bitte wählen Sie zwei Arbeitsplätze aus.';
                return;
            }
            if (wp1 === wp2) {
                messageDiv.textContent = 'Arbeitsplätze dürfen nicht identisch sein.';
                return;
            }

            const newLink = [wp1, wp2].sort(); 

            const alreadyLinked = linkedWorkplaces.some(link => 
                (link[0] === newLink[0] && link[1] === newLink[1])
            );

            if (alreadyLinked) {
                messageDiv.textContent = 'Diese Arbeitsplatz-Verknüpfung existiert bereits.';
                return;
            }

            const isAlreadyInAnotherLink = linkedWorkplaces.some(link => 
                link.includes(wp1) || link.includes(wp2)
            );

            if (isAlreadyInAnotherLink) {
                messageDiv.textContent = `Mindestens einer der Arbeitsplätze (${wp1} oder ${wp2}) ist bereits in einer anderen Verknüpfung enthalten. Ein Arbeitsplatz kann nur in einer Verknüpfung sein.`;
                return;
            }

            linkedWorkplaces.push(newLink);
            saveData();
            renderLinkedWorkplaces();
            messageDiv.textContent = `Verknüpfung "${wp1}" und "${wp2}" hinzugefügt.`;
            document.getElementById('selectWorkplace1').value = '';
            document.getElementById('selectWorkplace2').value = '';
        }

        function removeWorkplaceLink(index) {
            const removedLink = linkedWorkplaces.splice(index, 1);
            saveData();
            renderLinkedWorkplaces();
            document.getElementById('linkedWorkplaceMessage').textContent = `Verknüpfung "${removedLink[0][0]}" und "${removedLink[0][1]}" entfernt.`;
        }

        function renderLinkedWorkplaces() {
            const listDiv = document.getElementById('linkedWorkplacesList');
            listDiv.innerHTML = linkedWorkplaces.length === 0 ? 'Noch keine Arbeitsplätze verknüpft.' : '';

            linkedWorkplaces.forEach((link, index) => {
                const div = document.createElement('div');
                div.className = 'list-item';
                div.innerHTML = `<span>${link[0]} & <span style="font-weight: bold;">${link[1]}</span></span><button class="remove-btn-small" onclick="removeWorkplaceLink(${index})">X</button>`;
                listDiv.appendChild(div);
            });
        }

        function updateEmployeePairSelects() {
            const selectEmp1 = document.getElementById('selectEmployee1');
            const selectEmp2 = document.getElementById('selectEmployee2');
            
            selectEmp1.innerHTML = '<option value="">-- Mitarbeiter 1 auswählen --</option>';
            selectEmp2.innerHTML = '<option value="">-- Mitarbeiter 2 auswählen --</option>';

            employees.forEach(emp => {
                const option1 = document.createElement('option');
                option1.value = emp;
                option1.textContent = emp;
                selectEmp1.appendChild(option1);

                const option2 = document.createElement('option');
                option2.value = emp;
                option2.textContent = emp;
                selectEmp2.appendChild(option2);
            });
        }

        function addEmployeePair() {
            const emp1 = document.getElementById('selectEmployee1').value;
            const emp2 = document.getElementById('selectEmployee2').value;
            const maxPairings = parseInt(document.getElementById('maxPairingsPerDay').value, 10);
            const messageDiv = document.getElementById('employeePairMessage');
            messageDiv.textContent = '';

            if (!emp1 || !emp2) {
                messageDiv.textContent = 'Bitte wählen Sie zwei Mitarbeiter aus.';
                return;
            }
            if (emp1 === emp2) {
                messageDiv.textContent = 'Mitarbeiter dürfen nicht identisch sein.';
                return;
            }

            const newPair = [emp1, emp2].sort(); 
            
            const alreadyPaired = employeePairs.some(p => 
                (p.pair[0] === newPair[0] && p.pair[1] === newPair[1])
            );

            if (alreadyPaired) {
                messageDiv.textContent = 'Dieses Mitarbeiter-Paar existiert bereits.';
                return;
            }

            const isAlreadyInAnotherPair = employeePairs.some(p => 
                p.pair.includes(emp1) || p.pair.includes(emp2)
            );
            if (isAlreadyInAnotherPair) {
                messageDiv.textContent = `Mindestens einer der Mitarbeiter (${emp1} oder ${emp2}) ist bereits in einem anderen Paar enthalten. Ein Mitarbeiter kann nur in einem bevorzugten Paar sein.`;
                return;
            }

            employeePairs.push({ pair: newPair, maxDailyPairings: maxPairings });
            saveData();
            renderEmployeePairs();
            messageDiv.textContent = `Mitarbeiter-Paar "${emp1}" und "${emp2}" hinzugefügt (max. ${maxPairings} Runden/Tag).`;
            document.getElementById('selectEmployee1').value = '';
            document.getElementById('selectEmployee2').value = '';
            document.getElementById('maxPairingsPerDay').value = '1'; 
        }

        function removeEmployeePair(index) {
            const removedPair = employeePairs.splice(index, 1);
            saveData();
            renderEmployeePairs();
            document.getElementById('employeePairMessage').textContent = `Mitarbeiter-Paar "${removedPair[0].pair[0]}" und "${removedPair[0].pair[1]}" entfernt.`;
        }

        function renderEmployeePairs() {
            const listDiv = document.getElementById('employeePairsList');
            listDiv.innerHTML = employeePairs.length === 0 ? 'Noch keine Mitarbeiter-Paare verknüpft.' : '';

            employeePairs.forEach((pairObj, index) => {
                const div = document.createElement('div');
                div.className = 'list-item employee-pair-item';
                div.innerHTML = `
                    <span>${pairObj.pair[0]} & <span style="font-weight: bold;">${pairObj.pair[1]}</span></span>
                    <select onchange="updateEmployeePairMaxPairings(${index}, this.value)">
                        <option value="1" ${pairObj.maxDailyPairings === 1 ? 'selected' : ''}>1 Runde</option>
                        <option value="2" ${pairObj.maxDailyPairings === 2 ? 'selected' : ''}>2 Runden</option>
                        <option value="3" ${pairObj.maxDailyPairings === 3 ? 'selected' : ''}>3 Runden</option>
                        <option value="4" ${pairObj.maxDailyPairings === 4 ? 'selected' : ''}>4 Runden</option>
                    </select>
                    <button class="remove-btn-small" onclick="removeEmployeePair(${index})">X</button>
                `;
                listDiv.appendChild(div);
            });
        }

        function updateEmployeePairMaxPairings(index, newValue) {
            employeePairs[index].maxDailyPairings = parseInt(newValue, 10);
            saveData();
            displayMessage('Maximale gemeinsame Runden aktualisiert.', 'info');
        }

        function addEmployee() {
            const employeeNameInput = document.getElementById('employeeName');
            const name = employeeNameInput.value.trim();
            if (name && !employees.includes(name)) {
                employees.push(name);
                employeeSkills[name] = [];
                renderEmployeeList();
                updateEmployeeSelects();
                updatePresentEmployeeCheckboxes();
                updateEmployeePairSelects();
                employeeNameInput.value = '';
                displayMessage('', 'info'); 
                saveData(); 
            } else if (name && employees.includes(name)) {
                displayMessage('Mitarbeiter "' + name + '" existiert bereits.', 'error');
            } else {
                displayMessage('Bitte einen gültigen Mitarbeiternamen eingeben.', 'error');
            }
        }

        function removeEmployee(nameToRemove) {
            const isPaired = employeePairs.some(pairObj => pairObj.pair.includes(nameToRemove));
            if (isPaired) {
                displayMessage(`Fehler: Mitarbeiter "${nameToRemove}" ist Teil eines bevorzugten Paares und kann nicht gelöscht werden. Entfernen Sie zuerst das Paar im Admin-Menü.`, 'error');
                return;
            }

            employees = employees.filter(emp => emp !== nameToRemove);
            delete employeeSkills[nameToRemove]; 
            for (const day in allDailySchedules) {
                for (const rotation in allDailySchedules[day]) {
                    for (const workplace in allDailySchedules[day][rotation]) {
                        if (allDailySchedules[day][rotation][workplace] === nameToRemove) {
                            allDailySchedules[day][rotation][workplace] = 'N/A'; 
                        }
                    }
                }
            }
            renderEmployeeList();
            updateEmployeeSelects();
            updatePresentEmployeeCheckboxes();
            updateEmployeePairSelects();
            displayMessage(`Mitarbeiter "${nameToRemove}" wurde entfernt.`, 'info');
            saveData(); 
        }

        function renderEmployeeList() {
            const employeeListDiv = document.getElementById('employeeList');
            employeeListDiv.innerHTML = employees.length === 0 ? 'Noch keine Mitarbeiter hinzugefügt.' : '';
            employees.forEach((emp, index) => {
                const div = document.createElement('div');
                div.className = 'list-item';
                div.draggable = true;
                div.dataset.index = index;
                div.id = 'employee-' + emp.replace(/\s/g, '-');

                div.innerHTML = `<span>${emp}</span><button class="remove-btn" onclick="removeEmployee('${emp}')">X</button>`;
                
                div.addEventListener('dragstart', handleDragStart);
                div.addEventListener('dragover', handleDragOver);
                div.addEventListener('dragleave', handleDragLeave);
                div.addEventListener('drop', handleDrop);
                div.addEventListener('dragend', handleDragEnd);

                employeeListDiv.appendChild(div);
            });
        }

        let draggedEmployeeIndex = null;

        function handleDragStart(e) {
            draggedItem = e.target;
            draggedEmployeeIndex = parseInt(draggedItem.dataset.index);
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', draggedItem.innerHTML);
            
            setTimeout(() => {
                draggedItem.classList.add('dragging');
            }, 0);
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            if (e.target.classList.contains('list-item') && e.target !== draggedItem) {
                const rect = e.target.getBoundingClientRect();
                const offsetY = e.clientY - rect.top;
                if (offsetY < rect.height / 2) {
                    e.target.classList.add('drag-over');
                    e.target.classList.remove('drag-over-bottom');
                } else {
                    e.target.classList.add('drag-over-bottom');
                    e.target.classList.remove('drag-over');
                }
            }
        }

        function handleDragLeave(e) {
            e.target.classList.remove('drag-over', 'drag-over-bottom');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.target.classList.remove('drag-over', 'drag-over-bottom');

            if (e.target.classList.contains('list-item') && e.target !== draggedItem) {
                const targetEmployeeIndex = parseInt(e.target.dataset.index);
                const rect = e.target.getBoundingClientRect();
                const offsetY = e.clientY - rect.top;
                let newIndex = targetEmployeeIndex;

                if (offsetY > rect.height / 2) {
                    newIndex++;
                }
                
                if (draggedEmployeeIndex === null) return;

                const [movedEmployee] = employees.splice(draggedEmployeeIndex, 1);
                employees.splice(newIndex > draggedEmployeeIndex ? newIndex - 1 : newIndex, 0, movedEmployee);
                
                saveData();
                renderEmployeeList();
                updateEmployeeSelects();
                updatePresentEmployeeCheckboxes();
                updateEmployeePairSelects();
            }
        }

        function handleDragEnd(e) {
            draggedItem.classList.remove('dragging');
            draggedItem = null;
            draggedEmployeeIndex = null;
            document.querySelectorAll('.list-item').forEach(item => {
                item.classList.remove('drag-over', 'drag-over-bottom');
            });
        }


        function addWorkplace() {
            const workplaceNameInput = document.getElementById('workplaceName');
            const name = workplaceNameInput.value.trim();
            if (name && !workplaces.includes(name)) {
                workplaces.push(name);
                renderWorkplaceList();
                updateWorkplaceSelects();
                updateLinkedWorkplaceSelects(); 
                workplaceNameInput.value = '';
                displayMessage('', 'info'); 
                saveData(); 
                updatePresentEmployeeCheckboxes(); 
            } else if (name && workplaces.includes(name)) {
                displayMessage('Arbeitsplatz "' + name + '" existiert bereits.', 'error');
            } else {
                displayMessage('Bitte eine gültige Arbeitsplatzbezeichnung eingeben.', 'error');
            }
        }

        function removeWorkplace(nameToRemove) {
            const isLinked = linkedWorkplaces.some(link => link.includes(nameToRemove));
            if (isLinked) {
                displayMessage(`Fehler: Arbeitsplatz "${nameToRemove}" ist Teil einer Verknüpfung und kann nicht gelöscht werden. Entfernen Sie zuerst die Verknüpfung im Admin-Menü.`, 'error');
                return;
            }

            workplaces = workplaces.filter(wp => wp !== nameToRemove);
            
            for (const emp in employeeSkills) {
                employeeSkills[emp] = employeeSkills[emp].filter(skill => skill !== nameToRemove);
            }
            for (const day in allDailySchedules) {
                for (const rotation in allDailySchedules[day]) {
                    delete allDailySchedules[day][rotation][nameToRemove];
                }
            }

            renderWorkplaceList();
            updateWorkplaceSelects();
            updateLinkedWorkplaceSelects(); 
            displayEmployeeSkills(); 
            displayMessage(`Arbeitsplatz "${nameToRemove}" wurde entfernt.`, 'info');
            saveData(); 
            updatePresentEmployeeCheckboxes(); 
        }

        function renderWorkplaceList() {
            const workplaceListDiv = document.getElementById('workplaceList');
            workplaceListDiv.innerHTML = workplaces.length === 0 ? 'Noch keine Arbeitsplätze hinzugefügt.' : '';
            workplaces.forEach((wp, index) => {
                const div = document.createElement('div');
                div.className = 'list-item';
                div.draggable = true;
                div.dataset.index = index;
                div.id = 'workplace-' + wp.replace(/\s/g, '-');

                div.innerHTML = `<span>${wp}</span><button class="remove-btn" onclick="removeWorkplace('${wp}')">X</button>`;

                div.addEventListener('dragstart', handleWorkplaceDragStart);
                div.addEventListener('dragover', handleWorkplaceDragOver);
                div.addEventListener('dragleave', handleWorkplaceDragLeave);
                div.addEventListener('drop', handleWorkplaceDrop);
                div.addEventListener('dragend', handleWorkplaceDragEnd);

                workplaceListDiv.appendChild(div);
            });
        }

        let draggedWorkplaceIndex = null;

        function handleWorkplaceDragStart(e) {
            draggedItem = e.target;
            draggedWorkplaceIndex = parseInt(draggedItem.dataset.index);
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', draggedItem.innerHTML);
            
            setTimeout(() => {
                draggedItem.classList.add('dragging');
            }, 0);
        }

        function handleWorkplaceDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            if (e.target.classList.contains('list-item') && e.target !== draggedItem) {
                const rect = e.target.getBoundingClientRect();
                const offsetY = e.clientY - rect.top;
                if (offsetY < rect.height / 2) {
                    e.target.classList.add('drag-over');
                    e.target.classList.remove('drag-over-bottom');
                } else {
                    e.target.classList.add('drag-over-bottom');
                    e.target.classList.remove('drag-over');
                }
            }
        }

        function handleWorkplaceDragLeave(e) {
            e.target.classList.remove('drag-over', 'drag-over-bottom');
        }

        function handleWorkplaceDrop(e) {
            e.preventDefault();
            e.target.classList.remove('drag-over', 'drag-over-bottom');

            if (e.target.classList.contains('list-item') && e.target !== draggedItem) {
                const targetWorkplaceIndex = parseInt(e.target.dataset.index);
                const rect = e.target.getBoundingClientRect();
                const offsetY = e.clientY - rect.top;
                let newIndex = targetWorkplaceIndex;

                if (offsetY > rect.height / 2) {
                    newIndex++;
                }
                
                if (draggedWorkplaceIndex === null) return;

                const [movedWorkplace] = workplaces.splice(draggedWorkplaceIndex, 1);
                workplaces.splice(newIndex > draggedWorkplaceIndex ? newIndex - 1 : newIndex, 0, movedWorkplace);
                
                saveData();
                renderWorkplaceList();
                updateWorkplaceSelects();
                updateLinkedWorkplaceSelects();
                displayEmployeeSkills();
            }
        }

        function handleWorkplaceDragEnd(e) {
            draggedItem.classList.remove('dragging');
            draggedItem = null;
            draggedWorkplaceIndex = null;
            document.querySelectorAll('.list-item').forEach(item => {
                item.classList.remove('drag-over', 'drag-over-bottom');
            });
        }


        function updateEmployeeSelects() {
            const selectEmployee = document.getElementById('selectEmployeeForSkills');
            selectEmployee.innerHTML = '<option value="">-- Mitarbeiter auswählen --</option>';
            employees.forEach(emp => {
                const option = document.createElement('option');
                option.value = emp;
                option.textContent = emp;
                selectEmployee.appendChild(option);
            });
        }

        function updateWorkplaceSelects() {
            const selectWorkplaces = document.getElementById('selectWorkplacesForSkills');
            selectWorkplaces.innerHTML = '';
            document.getElementById('selectWorkplacesForSkills').size = Math.min(Math.max(workplaces.length, 4), 10);
            workplaces.forEach(wp => {
                const option = document.createElement('option');
                option.value = wp;
                option.textContent = wp;
                selectWorkplaces.appendChild(option);
            });
        }

        function displayEmployeeSkills() {
            const selectedEmployee = document.getElementById('selectEmployeeForSkills').value;
            const currentEmployeeSkillsDiv = document.getElementById('currentEmployeeSkills');
            currentEmployeeSkillsDiv.innerHTML = '';

            if (selectedEmployee && employeeSkills[selectedEmployee]) {
                if (employeeSkills[selectedEmployee].length > 0) {
                    employeeSkills[selectedEmployee].forEach(skill => {
                        const div = document.createElement('div');
                        div.className = 'list-item';
                        div.textContent = skill;
                        currentEmployeeSkillsDiv.appendChild(div);
                    });
                } else {
                    currentEmployeeSkillsDiv.textContent = 'Dieser Mitarbeiter hat noch keine zugewiesenen Fähigkeiten.';
                }
                const selectWorkplaces = document.getElementById('selectWorkplacesForSkills');
                Array.from(selectWorkplaces.options).forEach(option => {
                    option.selected = employeeSkills[selectedEmployee].includes(option.value);
                });
            } else {
                currentEmployeeSkillsDiv.textContent = 'Bitte einen Mitarbeiter auswählen.';
            }
        }

        function assignSkills() {
            const selectedEmployee = document.getElementById('selectEmployeeForSkills').value;
            const selectedWorkplaces = Array.from(document.getElementById('selectWorkplacesForSkills').selectedOptions).map(option => option.value);

            if (selectedEmployee) {
                employeeSkills[selectedEmployee] = selectedWorkplaces;
                displayEmployeeSkills(); 
                displayMessage(`Fähigkeiten für ${selectedEmployee} aktualisiert.`, 'info');
                saveData(); 
            } else {
                displayMessage('Bitte einen Mitarbeiter auswählen, dem Fähigkeiten zugewiesen werden sollen.', 'error');
            }
        }

        function updatePresentEmployeeCheckboxes() {
            const presentEmployeesDiv = document.getElementById('presentEmployeesCheckboxes');
            presentEmployeesDiv.innerHTML = ''; 

            if (employees.length === 0) {
                presentEmployeesDiv.textContent = 'Bitte zuerst Mitarbeiter hinzufügen.';
                return;
            }

            employees.forEach(emp => {
                const label = document.createElement('label');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.name = 'presentEmployee';
                checkbox.value = emp;
                checkbox.checked = false; 
                checkbox.addEventListener('change', updateSelectedEmployeeCount); 
                
                const span = document.createElement('span');
                span.textContent = emp;
                
                label.appendChild(checkbox);
                label.appendChild(span); 
                presentEmployeesDiv.appendChild(label);
            });
            updateSelectedEmployeeCount(); 
        }

        function updateSelectedEmployeeCount() {
            const presentCheckboxes = document.querySelectorAll('#presentEmployeesCheckboxes input[name="presentEmployee"]');
            const selectedCount = Array.from(presentCheckboxes).filter(cb => cb.checked).length;
            const requiredEmployees = workplaces.length; 

            const countDisplay = document.getElementById('selectedEmployeeCount');
            if (requiredEmployees === 0) {
                countDisplay.textContent = `Bitte Arbeitsplätze erstellen, um die benötigte Mitarbeiteranzahl zu sehen.`;
            } else {
                countDisplay.textContent = `Ausgewählte Mitarbeiter: ${selectedCount} von ${requiredEmployees} (benötigt)`;
            }
            
            manageEmployeeCheckboxes(selectedCount, requiredEmployees);
        }

        function manageEmployeeCheckboxes(selectedCount, requiredEmployees) {
            const presentCheckboxes = document.querySelectorAll('#presentEmployeesCheckboxes input[name="presentEmployee"]');

            if (selectedCount >= requiredEmployees && requiredEmployees > 0) { 
                presentCheckboxes.forEach(cb => {
                    if (!cb.checked) {
                        cb.disabled = true; 
                    }
                });
            } else {
                presentCheckboxes.forEach(cb => {
                    cb.disabled = false; 
                });
            }
        }

        function getPreviousDay(currentDay) {
            const days = ['Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'];
            const currentIndex = days.indexOf(currentDay);
            if (currentIndex > 0) {
                return days[currentIndex - 1];
            }
            return null; 
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]]; 
            }
        }

        function generateSchedule(startRotationIndex = 0) {
            const scheduleOutputDiv = document.getElementById('scheduleOutput');
            
            if (startRotationIndex === 0) {
                scheduleOutputDiv.innerHTML = ''; 
                document.getElementById('printScheduleBtn').style.display = 'none'; 
                displayMessage('', 'info'); 
                displayMessage('', 'error'); 
            }

            try {
                const dayOfWeek = document.getElementById('dayOfWeek').value;
                const presentCheckboxes = document.querySelectorAll('#presentEmployeesCheckboxes input[name="presentEmployee"]:checked');
                const initialAvailableEmployeesForDay = Array.from(presentCheckboxes).map(cb => cb.value); 

                const maxWorkplaceRepeats = parseInt(document.getElementById('maxWorkplaceRepeats').value, 10);

                if (workplaces.length === 0) {
                    displayMessage(`Fehler: Bitte erfasse mindestens einen Arbeitsplatz, um einen Plan zu erstellen.`, 'error');
                    return;
                }
                
                if (isNaN(maxWorkplaceRepeats) || maxWorkplaceRepeats < 1 || maxWorkplaceRepeats > 4) {
                    displayMessage('Fehler: Ungültiger Wert für "Max. Wiederholungen". Bitte geben Sie eine Zahl zwischen 1 und 4 ein.', 'error');
                    return;
                }

                if (initialAvailableEmployeesForDay.length !== workplaces.length) {
                    displayMessage(`Fehler: Es wurden ${initialAvailableEmployeesForDay.length} Mitarbeiter ausgewählt. Es müssen genau ${workplaces.length} Mitarbeiter ausgewählt werden, um alle Arbeitsplätze zu besetzen.`, 'error');
                    return;
                }
                
                const employeesWithoutSkills = initialAvailableEmployeesForDay.filter(emp => !employeeSkills[emp] || employeeSkills[emp].length === 0);
                if (employeesWithoutSkills.length > 0) {
                    displayMessage(`Fehler: Folgende ausgewählte Mitarbeiter haben noch keine Fähigkeiten zugewiesen: ${employeesWithoutSkills.join(', ')}. Bitte weisen Sie Fähigkeiten zu.`, 'error');
                    return;
                }

                const invalidLinkedWorkplaces = linkedWorkplaces.filter(link => 
                    !workplaces.includes(link[0]) || !workplaces.includes(link[1])
                );
                if (invalidLinkedWorkplaces.length > 0) {
                    displayMessage(`Fehler: Einige verknüpfte Arbeitsplätze existieren nicht mehr oder wurden umbenannt. Bitte prüfen Sie die Verknüpfungen im Admin-Menü.`, 'error');
                    return;
                }

                const rotations = ['1. Runde', '2. Runde', '3. Runde', '4. Runde'];
                if (!allDailySchedules[dayOfWeek] || startRotationIndex === 0) {
                    allDailySchedules[dayOfWeek] = {};
                    rotations.forEach(r => allDailySchedules[dayOfWeek][r] = {});
                }

                let employeeWorkplaceCounts = {}; 
                let employeeLastWorkplace = {}; 
                let employeePairDailyCounts = {}; 

                initialAvailableEmployeesForDay.forEach(emp => {
                    employeeWorkplaceCounts[emp] = {};
                    workplaces.forEach(wp => {
                        employeeWorkplaceCounts[emp][wp] = 0;
                    });
                    employeeLastWorkplace[emp] = null;
                });

                employeePairs.forEach(pairObj => {
                    const sortedPairKey = pairObj.pair.sort().join('_');
                    employeePairDailyCounts[sortedPairKey] = 0;
                });

                let overallOptimalSchedule = true; 

                const previousDay = getPreviousDay(dayOfWeek);
                const previousDaySchedule = allDailySchedules[previousDay] ? allDailySchedules[previousDay]['1. Runde'] : null;

                for (let r = 0; r < startRotationIndex; r++) {
                    const currentRotationName = rotations[r];
                    const manualAssignments = allDailySchedules[dayOfWeek][currentRotationName];
                    
                    for (const wp in manualAssignments) {
                        const emp = manualAssignments[wp];
                        if (emp && emp !== 'N/A' && emp !== 'UNPLANBAR' && employees.includes(emp)) {
                            if (!employeeWorkplaceCounts[emp]) {
                                employeeWorkplaceCounts[emp] = {};
                            }
                            if (!employeeWorkplaceCounts[emp][wp]) {
                                employeeWorkplaceCounts[emp][wp] = 0;
                            }
                            employeeWorkplaceCounts[emp][wp]++;
                            employeeLastWorkplace[emp] = wp;

                            employeePairs.forEach(pairObj => {
                                const sortedPairKey = pairObj.pair.sort().join('_');
                                if (pairObj.pair.includes(emp)) {
                                    const otherEmpInPair = pairObj.pair.find(e => e !== emp);
                                    if (manualAssignments[workplaces.find(w => manualAssignments[w] === otherEmpInPair)]) {
                                        employeePairDailyCounts[sortedPairKey]++;
                                    }
                                }
                            });
                        }
                    }
                }

                for (let i = startRotationIndex; i < rotations.length; i++) { 
                    const currentRotation = rotations[i];
                    let rotationAssignments = {};
                    
                    if (i < startRotationIndex && allDailySchedules[dayOfWeek][currentRotation]) {
                        rotationAssignments = {...allDailySchedules[dayOfWeek][currentRotation]};
                    } else {
                        workplaces.forEach(wp => rotationAssignments[wp] = 'N/A');
                    }

                    let currentRoundEmployeePool = [...initialAvailableEmployeesForDay]; 
                    
                    for (const wp in rotationAssignments) {
                        const assignedEmp = rotationAssignments[wp];
                        if (assignedEmp && assignedEmp !== 'N/A' && currentRoundEmployeePool.includes(assignedEmp)) {
                            currentRoundEmployeePool = currentRoundEmployeePool.filter(e => e !== assignedEmp);
                        }
                    }

                    let workplacesToAssign = [...workplaces].filter(wp => !rotationAssignments[wp] || rotationAssignments[wp] === 'N/A');

                    let unassignedLinkedWorkplaces = [...linkedWorkplaces].filter(link => 
                        workplacesToAssign.includes(link[0]) && workplacesToAssign.includes(link[1])
                    );

                    let remainingEmployeePairs = [...employeePairs].sort((a, b) => {
                        const keyA = a.pair.sort().join('_');
                        const keyB = b.pair.sort().join('_');
                        return employeePairDailyCounts[keyA] - employeePairDailyCounts[keyB]; 
                    });

                    shuffleArray(unassignedLinkedWorkplaces);

                    for (const link of unassignedLinkedWorkplaces) {
                        const wp1 = link[0];
                        const wp2 = link[1];
                        let assignedToLinked = false;
                        
                        if (rotationAssignments[wp1] && rotationAssignments[wp1] !== 'N/A' || rotationAssignments[wp2] && rotationAssignments[wp2] !== 'N/A') {
                            continue;
                        }

                        for (const pairObj of remainingEmployeePairs) {
                            const p1 = pairObj.pair[0];
                            const p2 = pairObj.pair[1];
                            const sortedPairKey = pairObj.pair.sort().join('_');

                            const bothAvailableInPool = currentRoundEmployeePool.includes(p1) && currentRoundEmployeePool.includes(p2);
                            
                            if (!bothAvailableInPool) {
                                continue; 
                            }

                            const p1_qual_wp1 = employeeSkills[p1].includes(wp1);
                            const p1_qual_wp2 = employeeSkills[p1].includes(wp2);
                            const p2_qual_wp1 = employeeSkills[p2].includes(wp1);
                            const p2_qual_wp2 = employeeSkills[p2].includes(wp2);
                            
                            const pairCanCoverWorkplaces = 
                                (p1_qual_wp1 && p2_qual_wp2) || (p1_qual_wp2 && p2_qual_wp1);
                            
                            if (pairCanCoverWorkplaces) {
                                if (employeePairDailyCounts[sortedPairKey] < pairObj.maxDailyPairings) {
                                    let employee1_candidate = null;
                                    let employee2_candidate = null;

                                    if (p1_qual_wp1 && p2_qual_wp1) { 
                                        if (rotationAssignments[wp1] === p1 && rotationAssignments[wp2] === p2) {
                                            employee1_candidate = p1;
                                            employee2_candidate = p2;
                                        } else if (rotationAssignments[wp1] === p2 && rotationAssignments[wp2] === p1) {
                                            employee1_candidate = p2;
                                            employee2_candidate = p1;
                                        } else { 
                                            employee1_candidate = p1;
                                            employee2_candidate = p2;
                                        }
                                    }
                                    if (p1_qual_wp1 && p2_qual_wp2) {
                                        employee1_candidate = p1;
                                        employee2_candidate = p2;
                                    } else if (p1_qual_wp2 && p2_qual_wp1) { 
                                        employee1_candidate = p2;
                                        employee2_candidate = p1;
                                    }

                                    if (employee1_candidate && employee2_candidate) {
                                        rotationAssignments[wp1] = employee1_candidate;
                                        rotationAssignments[wp2] = employee2_candidate;
                                        
                                        currentRoundEmployeePool = currentRoundEmployeePool.filter(emp => emp !== employee1_candidate && emp !== employee2_candidate);
                                        
                                        employeeWorkplaceCounts[employee1_candidate][wp1]++;
                                        employeeWorkplaceCounts[employee2_candidate][wp2]++;
                                        employeeLastWorkplace[employee1_candidate] = wp1;
                                        employeeLastWorkplace[employee2_candidate] = wp2;
                                        employeePairDailyCounts[sortedPairKey]++;
                                        assignedToLinked = true;
                                        break; 
                                    }
                                }
                            }
                        }

                        if (assignedToLinked) {
                            workplacesToAssign = workplacesToAssign.filter(w => w !== wp1 && w !== wp2);
                        } else {
                            overallOptimalSchedule = false; 
                        }
                    }

                    let remainingWorkplacesToAssign = [...workplacesToAssign].filter(wp => !rotationAssignments[wp] || rotationAssignments[wp] === 'N/A');

                    let currentWorkplacesWithCandidates = remainingWorkplacesToAssign.map(wp => { 
                        return {
                            name: wp,
                            qualifiedAndAvailable: currentRoundEmployeePool.filter(emp => 
                                employeeSkills[emp].includes(wp)
                            )
                        };
                    });

                    currentWorkplacesWithCandidates.sort((a, b) => {
                        const a_count = a.qualifiedAndAvailable.length;
                        const b_count = b.qualifiedAndAvailable.length;
                        return a_count - b_count;
                    });
                    
                    for (const workplaceObj of currentWorkplacesWithCandidates) {
                        const currentWorkplace = workplaceObj.name;
                        let assigned = false;

                        let currentEligibleEmployees = workplaceObj.qualifiedAndAvailable.filter(emp => currentRoundEmployeePool.includes(emp));
                        
                        shuffleArray(currentEligibleEmployees); 

                        let optimalCandidates = [...currentEligibleEmployees].sort((a, b) => {
                            const a_consecutive_score = (employeeLastWorkplace[a] === currentWorkplace) ? 1 : 0;
                            const b_consecutive_score = (employeeLastWorkplace[b] === currentWorkplace) ? 1 : 0;
                            if (a_consecutive_score !== b_consecutive_score) {
                                return a_consecutive_score - b_consecutive_score;
                            }

                            const a_repeats = employeeWorkplaceCounts[a][currentWorkplace];
                            const b_repeats = employeeWorkplaceCounts[b][currentWorkplace];
                            if (a_repeats !== b_repeats) {
                                return a_repeats - b_repeats;
                            }
                            
                            if (i === 0 && previousDaySchedule) { 
                                const a_was_at_same_wp_prev_day = (previousDaySchedule[currentWorkplace] === a) ? 1 : 0;
                                const b_was_at_same_wp_prev_day = (previousDaySchedule[currentWorkplace] === b) ? 1 : 0;
                                if (a_was_at_same_wp_prev_day !== b_was_at_same_wp_prev_day) {
                                    return a_was_at_same_wp_prev_day - b_was_at_same_wp_prev_day;
                                }
                            }

                            const a_unique_workplaces = Object.values(employeeWorkplaceCounts[a]).filter(count => count > 0).length;
                            const b_unique_workplaces = Object.values(employeeWorkplaceCounts[b]).filter(count => count > 0).length;
                            return b_unique_workplaces - a_unique_workplaces; 
                        });

                        for (const emp of optimalCandidates) {
                            if (currentRoundEmployeePool.includes(emp)) { 
                                if (employeeWorkplaceCounts[emp][currentWorkplace] < maxWorkplaceRepeats) {
                                    rotationAssignments[currentWorkplace] = emp;
                                    currentRoundEmployeePool = currentRoundEmployeePool.filter(e => e !== emp); 
                                    employeeWorkplaceCounts[emp][currentWorkplace]++;
                                    employeeLastWorkplace[emp] = currentWorkplace;
                                    assigned = true;
                                    break;
                                } else {
                                    overallOptimalSchedule = false; 
                                }
                            }
                        }

                        if (!assigned) {
                            overallOptimalSchedule = false; 
                            for (const emp of currentEligibleEmployees) { 
                                if (currentRoundEmployeePool.includes(emp)) { 
                                    rotationAssignments[currentWorkplace] = emp;
                                    currentRoundEmployeePool = currentRoundEmployeePool.filter(e => e !== emp);
                                    employeeWorkplaceCounts[emp][currentWorkplace]++;
                                    employeeLastWorkplace[emp] = currentWorkplace;
                                    assigned = true;
                                    break;
                                }
                            }
                        }

                        if (!assigned) {
                            rotationAssignments[currentWorkplace] = 'UNPLANBAR';
                            displayMessage(`Kritischer Fehler: Arbeitsplatz "${currentWorkplace}" konnte nicht besetzt werden. Es gibt keine qualifizierten Mitarbeiter mehr, die in dieser Runde zugewiesen werden können.`, 'error');
                            overallOptimalSchedule = false;
                        }
                    }
                    allDailySchedules[dayOfWeek][currentRotation] = rotationAssignments;
                }

                saveData();
                if (startRotationIndex === 0) {
                    displayMessage('Schichtplan erfolgreich generiert und online gespeichert!', 'info');
                } else {
                    displayMessage(`Runden ${rotations[startRotationIndex]} bis ${rotations[rotations.length - 1]} neu generiert und gespeichert!`, 'info');
                }

                renderScheduleTable(dayOfWeek);
                document.getElementById('printScheduleBtn').style.display = 'block';

            } catch (error) {
                console.error("Fehler bei der Schichtplanerstellung:", error);
                displayMessage(`Ein unerwarteter Fehler ist aufgetreten: ${error.message}.`, 'error');
                document.getElementById('printScheduleBtn').style.display = 'none';
            }
        }

        function renderScheduleTable(day) {
            const scheduleOutputDiv = document.getElementById('scheduleOutput');
            scheduleOutputDiv.innerHTML = ''; 

            const header = document.createElement('h2');
            header.textContent = `Schichtplan für ${day}`;
            scheduleOutputDiv.appendChild(header);

            const table = document.createElement('table');
            table.className = 'schedule-table';
            const thead = document.createElement('thead');
            const tbody = document.createElement('tbody');

            let headerRow = document.createElement('tr');
            let thCorner = document.createElement('th');
            thCorner.textContent = 'Arbeitsplatz';
            headerRow.appendChild(thCorner);
            const rotations = ['1. Runde', '2. Runde', '3. Runde', '4. Runde'];
            rotations.forEach(round => {
                let th = document.createElement('th');
                th.textContent = round;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            workplaces.forEach(wp => {
                let row = document.createElement('tr');
                let tdWorkplace = document.createElement('td');
                tdWorkplace.textContent = wp;
                row.appendChild(tdWorkplace);

                rotations.forEach((rotation, index) => {
                    let td = document.createElement('td');
                    td.textContent = (allDailySchedules[day] && allDailySchedules[day][rotation] && allDailySchedules[day][rotation][wp]) || 'N/A';
                    td.setAttribute('contenteditable', 'true');
                    td.dataset.rotation = rotation;
                    td.dataset.workplace = wp;
                    td.dataset.day = day;

                    td.addEventListener('blur', function() {
                        const editedDay = this.dataset.day;
                        const editedRotation = this.dataset.rotation;
                        const editedWorkplace = this.dataset.workplace;
                        const newValue = this.textContent.trim();
                        
                        if (newValue !== '') {
                            if (!allDailySchedules[editedDay]) allDailySchedules[editedDay] = {};
                            if (!allDailySchedules[editedDay][editedRotation]) allDailySchedules[editedDay][editedRotation] = {};
                            allDailySchedules[editedDay][editedRotation][editedWorkplace] = newValue;
                            saveData();
                            displayMessage('Manuelle Änderung gespeichert!', 'info');
                            
                            const editedRotationIndex = rotations.indexOf(editedRotation);
                            if (editedRotationIndex < rotations.length -1) { 
                                generateSchedule(editedRotationIndex + 1); 
                            } else {
                                renderScheduleTable(document.getElementById('dayOfWeek').value);
                            }
                        }
                    });
                    row.appendChild(td);
                });
                tbody.appendChild(row);
            });
            table.appendChild(tbody);
            scheduleOutputDiv.appendChild(table);

            const allTds = document.querySelectorAll('.schedule-table td[data-day]');
            allTds.forEach(td => {
                const day = td.dataset.day;
                const rotation = td.dataset.rotation;
                const employeeName = td.textContent.trim();
                checkAndColorCell(td, employeeName, rotation, day);
            });
        }


        function checkAndColorCell(cellElement, employeeName, rotation, day) {
            cellElement.classList.remove('error-duplicate', 'warn-skill', 'warn-unknown', 'auto-compromise');
            cellElement.style.backgroundColor = ''; 
            let cellWarnings = [];

            const workplace = cellElement.dataset.workplace;
            const currentRotationData = allDailySchedules[day] ? allDailySchedules[day][rotation] : null;

            if (!currentRotationData) return;

            if (employeeName === 'UNPLANBAR') {
                cellWarnings.push('Konnte nicht automatisch geplant werden.');
                cellElement.classList.add('error-duplicate');
            } else if (employeeName === 'N/A') {
                // No special handling
            }
            else if (!employees.includes(employeeName)) {
                cellWarnings.push('Warnung: Mitarbeiter ist nicht registriert.');
                cellElement.classList.add('warn-unknown');
            }
            else if (employeeSkills[employeeName] && !employeeSkills[employeeName].includes(workplace)) {
                cellWarnings.push(`Warnung: ${employeeName} hat keine Fähigkeit für ${workplace}.`);
                cellElement.classList.add('warn-skill');
            }

            if (employeeName && employeeName !== 'N/A' && employeeName !== 'UNPLANBAR' && employees.includes(employeeName)) {
                let countInRotation = 0;
                for (const wpKey in currentRotationData) {
                    if (currentRotationData[wpKey] === employeeName) {
                        countInRotation++;
                    }
                }
                if (countInRotation > 1) {
                    cellWarnings.push(`Fehler: Dieser Mitarbeiter ist in dieser Runde mehrfach zugewiesen!`);
                    cellElement.classList.add('error-duplicate');
                }
            }

            for (const link of linkedWorkplaces) {
                const wp1 = link[0];
                const wp2 = link[1];

                if (workplace === wp1 || workplace === wp2) {
                    const emp1 = currentRotationData[wp1];
                    const emp2 = currentRotationData[wp2];

                    const areBothAssigned = (emp1 && emp1 !== 'N/A' && emp1 !== 'UNPLANBAR') && (emp2 && emp2 !== 'N/A' && emp2 !== 'UNPLANBAR');
                    const areBothUnassigned = (!emp1 || emp1 === 'N/A' || emp1 === 'UNPLANBAR') && (!emp2 || emp2 === 'N/A' || emp2 === 'UNPLANBAR');
                    
                    if (!areBothAssigned && !areBothUnassigned) {
                        cellWarnings.push(`Warnung: Verknüpfte Arbeitsplätze ${wp1} und ${wp2} sind nicht korrekt zusammen besetzt.`);
                        cellElement.classList.add('warn-skill');
                    } else if (areBothAssigned && emp1 === emp2) {
                        cellWarnings.push(`Fehler: Derselbe Mitarbeiter (${emp1}) an verknüpften Arbeitsplätzen ${wp1} und ${wp2}.`);
                        cellElement.classList.add('error-duplicate');
                    }
                }
            }
            
            cellElement.title = cellWarnings.join('\n');
            if (cellWarnings.length === 0) {
                cellElement.title = '';
            }
        }


        function printSchedule() {
            const scheduleOutputContent = document.getElementById('scheduleOutput').innerHTML;
            const dayOfWeek = document.getElementById('dayOfWeek').value;

            const printContent = `
                <html>
                <head>
                    <title>Schichtplan ${dayOfWeek} - ${currentGroup} / ${currentShift}</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; }
                        h2 { color: #0056b3; text-align: center; margin-bottom: 20px;}
                        table { width: 100%; border-collapse: collapse; margin-top: 15px; }
                        th, td { border: 1px solid #ddd; padding: 10px; text-align: left; }
                        th { background-color: #e2f0ff; color: #0056b3; }
                        td { background-color: #fff; }
                        td[style*="background-color"] { -webkit-print-color-adjust: exact; color-adjust: exact; }
                        td.error-duplicate { background-color: #ff6666 !important; }
                        td.warn-skill { background-color: #ffaa00 !important; }
                        td.warn-unknown { background-color: #a0a0a0 !important; }
                        td.auto-compromise { background-color: #ffddaa !important; }
                        @page { margin: 1cm; }
                    </style>
                </head>
                <body>
                    ${scheduleOutputContent}
                </body>
                </html>
            `;

            const printWindow = window.open('', '_blank');
            printWindow.document.open();
            printWindow.document.write(printContent);
            printWindow.document.close();

            printWindow.onload = function() {
                printWindow.focus();
                printWindow.print();
            };
        }

        function displayMessage(message, type) {
            const errorMessageDiv = document.getElementById('errorMessage');
            const infoMessageDiv = document.getElementById('infoMessage');

            if (type === 'error') {
                errorMessageDiv.textContent = message;
            } else if (type === 'info') {
                infoMessageDiv.textContent = message;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            // App wartet auf den Nutzer im Startbildschirm
        });

        function exportToJSON() {
            const dataToExport = {
                employees, workplaces, employeeSkills,
                allDailySchedules, linkedWorkplaces, employeePairs
            };

            const jsonStr = JSON.stringify(dataToExport, null, 2);
            const blob = new Blob([jsonStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.href = url;
            link.download = `schichtplan-daten-${currentGroup}-${currentShift}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function importFromJSON(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    employees = importedData.employees || [];
                    workplaces = importedData.workplaces || [];
                    employeeSkills = importedData.employeeSkills || {};
                    allDailySchedules = importedData.allDailySchedules || {};
                    linkedWorkplaces = importedData.linkedWorkplaces || [];
                    employeePairs = importedData.employeePairs || [];

                    saveData();
                    
                    renderEmployeeList();
                    renderWorkplaceList();
                    updateEmployeeSelects();
                    updateWorkplaceSelects();
                    updateLinkedWorkplaceSelects();
                    updateEmployeePairSelects();
                    updatePresentEmployeeCheckboxes();
                    renderLinkedWorkplaces();
                    renderEmployeePairs();

                    displayMessage('Daten erfolgreich importiert und online gespeichert.', 'info');
                } catch (error) {
                    displayMessage('Fehler beim Importieren der Datei: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        }
    </script>
</body>
</html>