<script>
        // *** HIER DEINE KOPIERTE WEB-APP-URL EINFÜGEN ***
        const G_SCRIPT_URL = '<script>
        // *** HIER DEINE KOPIERTE WEB-APP-URL EINFÜGEN ***
        const G_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbxPBEqbokAxppLQukwrrvMHeP55I8CFxLS5npsFLY8fPaG7RhrLHFg6VdxGjY482xFc/exec';

        let employees = [];
        let workplaces = [];
        let employeeSkills = {}; // { employeeName: [workplace1, workplace2], ... }
        let allDailySchedules = {}; // { 'Montag': { '1. Runde': { 'WP1': 'EmpA' } }, 'Dienstag': { ... } }
        let linkedWorkplaces = []; // [[wp1, wp2], [wp3, wp4]]
        let employeePairs = []; // [{ pair: ['Mitarbeiter A', 'Mitarbeiter B'], maxDailyPairings: 2 }]

        let draggedItem = null;

        // --- NEUE Funktionen zum Speichern und Laden der Daten über Google Apps Script ---
        async function saveData() {
            const dataPayload = {
                employees,
                workplaces,
                employeeSkills,
                allDailySchedules,
                linkedWorkplaces,
                employeePairs
            };

            displayMessage('Speichere Daten online...', 'info');

            try {
                const response = await fetch(G_SCRIPT_URL, {
                    method: 'POST',
                    mode: 'cors', // Wichtig für Cross-Origin-Anfragen
                    headers: {
                        'Content-Type': 'text/plain;charset=utf-8', // Apps Script erwartet text/plain für postData
                    },
                    body: JSON.stringify(dataPayload)
                });
                const result = await response.json();

                if (result.status === 'success') {
                    displayMessage('Daten erfolgreich online gespeichert!', 'info');
                } else {
                    throw new Error(result.message);
                }
            } catch (error) {
                console.error('Fehler beim Speichern:', error);
                displayMessage(`Fehler beim Speichern der Daten: ${error.message}`, 'error');
            }
        }

        async function loadData() {
            displayMessage('Lade Daten vom Server...', 'info');
            try {
                const response = await fetch(G_SCRIPT_URL);
                const data = await response.json();

                if (data) {
                    employees = data.employees || [];
                    workplaces = data.workplaces || [];
                    employeeSkills = data.employeeSkills || {};
                    allDailySchedules = data.allDailySchedules || {};
                    linkedWorkplaces = data.linkedWorkplaces || [];
                    employeePairs = data.employeePairs || [];
                }
                 displayMessage('Daten erfolgreich geladen.', 'info');
            } catch (error) {
                console.error('Fehler beim Laden der Daten:', error);
                displayMessage(`Konnte keine Daten laden. Eventuell ist es der erste Start. (${error.message})`, 'error');
            }
            
            // Komplette UI nach dem Laden aktualisieren
            renderEmployeeList();
            renderWorkplaceList();
            updateEmployeeSelects();
            updateWorkplaceSelects();
            updatePresentEmployeeCheckboxes();
            updateLinkedWorkplaceSelects();
            updateEmployeePairSelects();
            renderLinkedWorkplaces();
            renderEmployeePairs();
        }


        // --- Admin-Menü Funktionen ---
        function openAdminLogin() {
            document.getElementById('adminOverlay').style.display = 'flex';
            document.getElementById('adminLogin').style.display = 'block';
            document.getElementById('adminMenuContent').style.display = 'none';
            document.getElementById('adminUsername').value = '';
            document.getElementById('adminPassword').value = '';
            document.getElementById('adminLoginMessage').textContent = '';
        }

        function closeAdminMenu() {
            document.getElementById('adminOverlay').style.display = 'none';
        }

        function loginAdmin() {
            const username = document.getElementById('adminUsername').value;
            const password = document.getElementById('adminPassword').value;
            const loginMessageDiv = document.getElementById('adminLoginMessage');

            if (username === 'admin' && password === 'admin') {
                document.getElementById('adminLogin').style.display = 'none';
                document.getElementById('adminMenuContent').style.display = 'block';
                updateLinkedWorkplaceSelects();
                renderLinkedWorkplaces();
                updateEmployeePairSelects();
                renderEmployeePairs();
                loginMessageDiv.textContent = '';
            } else {
                loginMessageDiv.textContent = 'Falscher Benutzername oder Passwort.';
            }
        }

        // --- Arbeitsplatz-Verknüpfungs-Funktionen ---
        function updateLinkedWorkplaceSelects() {
            const selectWp1 = document.getElementById('selectWorkplace1');
            const selectWp2 = document.getElementById('selectWorkplace2');
            
            selectWp1.innerHTML = '<option value="">-- Arbeitsplatz 1 auswählen --</option>';
            selectWp2.innerHTML = '<option value="">-- Arbeitsplatz 2 auswählen --</option>';

            workplaces.forEach(wp => {
                const option1 = document.createElement('option');
                option1.value = wp;
                option1.textContent = wp;
                selectWp1.appendChild(option1);

                const option2 = document.createElement('option');
                option2.value = wp;
                option2.textContent = wp;
                selectWp2.appendChild(option2);
            });
        }

        function addWorkplaceLink() {
            const wp1 = document.getElementById('selectWorkplace1').value;
            const wp2 = document.getElementById('selectWorkplace2').value;
            const messageDiv = document.getElementById('linkedWorkplaceMessage');
            messageDiv.textContent = ''; 

            if (!wp1 || !wp2) {
                messageDiv.textContent = 'Bitte wählen Sie zwei Arbeitsplätze aus.';
                return;
            }
            if (wp1 === wp2) {
                messageDiv.textContent = 'Arbeitsplätze dürfen nicht identisch sein.';
                return;
            }

            const newLink = [wp1, wp2].sort(); 

            const alreadyLinked = linkedWorkplaces.some(link => 
                (link[0] === newLink[0] && link[1] === newLink[1])
            );

            if (alreadyLinked) {
                messageDiv.textContent = 'Diese Arbeitsplatz-Verknüpfung existiert bereits.';
                return;
            }

            const isAlreadyInAnotherLink = linkedWorkplaces.some(link => 
                link.includes(wp1) || link.includes(wp2)
            );

            if (isAlreadyInAnotherLink) {
                messageDiv.textContent = `Mindestens einer der Arbeitsplätze (${wp1} oder ${wp2}) ist bereits in einer anderen Verknüpfung enthalten. Ein Arbeitsplatz kann nur in einer Verknüpfung sein.`;
                return;
            }

            linkedWorkplaces.push(newLink);
            saveData();
            renderLinkedWorkplaces();
            messageDiv.textContent = `Verknüpfung "${wp1}" und "${wp2}" hinzugefügt.`;
            document.getElementById('selectWorkplace1').value = '';
            document.getElementById('selectWorkplace2').value = '';
        }

        function removeWorkplaceLink(index) {
            const removedLink = linkedWorkplaces.splice(index, 1);
            saveData();
            renderLinkedWorkplaces();
            document.getElementById('linkedWorkplaceMessage').textContent = `Verknüpfung "${removedLink[0][0]}" und "${removedLink[0][1]}" entfernt.`;
        }

        function renderLinkedWorkplaces() {
            const listDiv = document.getElementById('linkedWorkplacesList');
            listDiv.innerHTML = linkedWorkplaces.length === 0 ? 'Noch keine Arbeitsplätze verknüpft.' : '';

            linkedWorkplaces.forEach((link, index) => {
                const div = document.createElement('div');
                div.className = 'list-item';
                div.innerHTML = `<span>${link[0]} & <span style="font-weight: bold;">${link[1]}</span></span><button class="remove-btn-small" onclick="removeWorkplaceLink(${index})">X</button>`;
                listDiv.appendChild(div);
            });
        }

        // --- Mitarbeiter-Paar Verknüpfungs-Funktionen ---
        function updateEmployeePairSelects() {
            const selectEmp1 = document.getElementById('selectEmployee1');
            const selectEmp2 = document.getElementById('selectEmployee2');
            
            selectEmp1.innerHTML = '<option value="">-- Mitarbeiter 1 auswählen --</option>';
            selectEmp2.innerHTML = '<option value="">-- Mitarbeiter 2 auswählen --</option>';

            employees.forEach(emp => {
                const option1 = document.createElement('option');
                option1.value = emp;
                option1.textContent = emp;
                selectEmp1.appendChild(option1);

                const option2 = document.createElement('option');
                option2.value = emp;
                option2.textContent = emp;
                selectEmp2.appendChild(option2);
            });
        }

        function addEmployeePair() {
            const emp1 = document.getElementById('selectEmployee1').value;
            const emp2 = document.getElementById('selectEmployee2').value;
            const maxPairings = parseInt(document.getElementById('maxPairingsPerDay').value, 10);
            const messageDiv = document.getElementById('employeePairMessage');
            messageDiv.textContent = '';

            if (!emp1 || !emp2) {
                messageDiv.textContent = 'Bitte wählen Sie zwei Mitarbeiter aus.';
                return;
            }
            if (emp1 === emp2) {
                messageDiv.textContent = 'Mitarbeiter dürfen nicht identisch sein.';
                return;
            }

            const newPair = [emp1, emp2].sort(); 
            
            const alreadyPaired = employeePairs.some(p => 
                (p.pair[0] === newPair[0] && p.pair[1] === newPair[1])
            );

            if (alreadyPaired) {
                messageDiv.textContent = 'Dieses Mitarbeiter-Paar existiert bereits.';
                return;
            }

            const isAlreadyInAnotherPair = employeePairs.some(p => 
                p.pair.includes(emp1) || p.pair.includes(emp2)
            );
            if (isAlreadyInAnotherPair) {
                messageDiv.textContent = `Mindestens einer der Mitarbeiter (${emp1} oder ${emp2}) ist bereits in einem anderen Paar enthalten. Ein Mitarbeiter kann nur in einem bevorzugten Paar sein.`;
                return;
            }

            employeePairs.push({ pair: newPair, maxDailyPairings: maxPairings });
            saveData();
            renderEmployeePairs();
            messageDiv.textContent = `Mitarbeiter-Paar "${emp1}" und "${emp2}" hinzugefügt (max. ${maxPairings} Runden/Tag).`;
            document.getElementById('selectEmployee1').value = '';
            document.getElementById('selectEmployee2').value = '';
            document.getElementById('maxPairingsPerDay').value = '1'; 
        }

        function removeEmployeePair(index) {
            const removedPair = employeePairs.splice(index, 1);
            saveData();
            renderEmployeePairs();
            document.getElementById('employeePairMessage').textContent = `Mitarbeiter-Paar "${removedPair[0].pair[0]}" und "${removedPair[0].pair[1]}" entfernt.`;
        }

        function renderEmployeePairs() {
            const listDiv = document.getElementById('employeePairsList');
            listDiv.innerHTML = employeePairs.length === 0 ? 'Noch keine Mitarbeiter-Paare verknüpft.' : '';

            employeePairs.forEach((pairObj, index) => {
                const div = document.createElement('div');
                div.className = 'list-item employee-pair-item';
                div.innerHTML = `
                    <span>${pairObj.pair[0]} & <span style="font-weight: bold;">${pairObj.pair[1]}</span></span>
                    <select onchange="updateEmployeePairMaxPairings(${index}, this.value)">
                        <option value="1" ${pairObj.maxDailyPairings === 1 ? 'selected' : ''}>1 Runde</option>
                        <option value="2" ${pairObj.maxDailyPairings === 2 ? 'selected' : ''}>2 Runden</option>
                        <option value="3" ${pairObj.maxDailyPairings === 3 ? 'selected' : ''}>3 Runden</option>
                        <option value="4" ${pairObj.maxDailyPairings === 4 ? 'selected' : ''}>4 Runden</option>
                    </select>
                    <button class="remove-btn-small" onclick="removeEmployeePair(${index})">X</button>
                `;
                listDiv.appendChild(div);
            });
        }

        function updateEmployeePairMaxPairings(index, newValue) {
            employeePairs[index].maxDailyPairings = parseInt(newValue, 10);
            saveData();
            displayMessage('Maximale gemeinsame Runden aktualisiert.', 'info');
        }

        // --- Funktionen zum Hinzufügen und Anzeigen von Mitarbeitern ---
        function addEmployee() {
            const employeeNameInput = document.getElementById('employeeName');
            const name = employeeNameInput.value.trim();
            if (name && !employees.includes(name)) {
                employees.push(name);
                employeeSkills[name] = [];
                renderEmployeeList();
                updateEmployeeSelects();
                updatePresentEmployeeCheckboxes();
                updateEmployeePairSelects();
                employeeNameInput.value = '';
                displayMessage('', 'info'); 
                saveData(); 
            } else if (name && employees.includes(name)) {
                displayMessage('Mitarbeiter "' + name + '" existiert bereits.', 'error');
            } else {
                displayMessage('Bitte einen gültigen Mitarbeiternamen eingeben.', 'error');
            }
        }

        function removeEmployee(nameToRemove) {
            const isPaired = employeePairs.some(pairObj => pairObj.pair.includes(nameToRemove));
            if (isPaired) {
                displayMessage(`Fehler: Mitarbeiter "${nameToRemove}" ist Teil eines bevorzugten Paares und kann nicht gelöscht werden. Entfernen Sie zuerst das Paar im Admin-Menü.`, 'error');
                return;
            }

            employees = employees.filter(emp => emp !== nameToRemove);
            delete employeeSkills[nameToRemove]; 
            for (const day in allDailySchedules) {
                for (const rotation in allDailySchedules[day]) {
                    for (const workplace in allDailySchedules[day][rotation]) {
                        if (allDailySchedules[day][rotation][workplace] === nameToRemove) {
                            allDailySchedules[day][rotation][workplace] = 'N/A'; 
                        }
                    }
                }
            }
            renderEmployeeList();
            updateEmployeeSelects();
            updatePresentEmployeeCheckboxes();
            updateEmployeePairSelects();
            displayMessage(`Mitarbeiter "${nameToRemove}" wurde entfernt.`, 'info');
            saveData(); 
        }

        function renderEmployeeList() {
            const employeeListDiv = document.getElementById('employeeList');
            employeeListDiv.innerHTML = employees.length === 0 ? 'Noch keine Mitarbeiter hinzugefügt.' : '';
            employees.forEach((emp, index) => {
                const div = document.createElement('div');
                div.className = 'list-item';
                div.draggable = true; // Make draggable
                div.dataset.index = index; // Store original index
                div.id = 'employee-' + emp.replace(/\s/g, '-'); // Unique ID for drag-drop

                div.innerHTML = `<span>${emp}</span><button class="remove-btn" onclick="removeEmployee('${emp}')">X</button>`;
                
                // Add drag-and-drop event listeners
                div.addEventListener('dragstart', handleDragStart);
                div.addEventListener('dragover', handleDragOver);
                div.addEventListener('dragleave', handleDragLeave);
                div.addEventListener('drop', handleDrop);
                div.addEventListener('dragend', handleDragEnd);

                employeeListDiv.appendChild(div);
            });
        }

        // --- Functions for Drag and Drop (Employees) ---
        let draggedEmployeeIndex = null;

        function handleDragStart(e) {
            draggedItem = e.target;
            draggedEmployeeIndex = parseInt(draggedItem.dataset.index);
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', draggedItem.innerHTML); // Required for Firefox
            
            setTimeout(() => {
                draggedItem.classList.add('dragging');
            }, 0); // Add class after drag started to hide the original item immediately
        }

        function handleDragOver(e) {
            e.preventDefault(); // Necessary to allow dropping
            e.dataTransfer.dropEffect = 'move';
            if (e.target.classList.contains('list-item') && e.target !== draggedItem) {
                // Determine if dropping above or below
                const rect = e.target.getBoundingClientRect();
                const offsetY = e.clientY - rect.top;
                if (offsetY < rect.height / 2) {
                    e.target.classList.add('drag-over');
                    e.target.classList.remove('drag-over-bottom');
                } else {
                    e.target.classList.add('drag-over-bottom');
                    e.target.classList.remove('drag-over');
                }
            }
        }

        function handleDragLeave(e) {
            e.target.classList.remove('drag-over', 'drag-over-bottom');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.target.classList.remove('drag-over', 'drag-over-bottom');

            if (e.target.classList.contains('list-item') && e.target !== draggedItem) {
                const targetEmployeeIndex = parseInt(e.target.dataset.index);
                const rect = e.target.getBoundingClientRect();
                const offsetY = e.clientY - rect.top;
                let newIndex = targetEmployeeIndex;

                if (offsetY > rect.height / 2) {
                    newIndex++; // Drop below the target item
                }
                
                if (draggedEmployeeIndex === null) return; // Should not happen

                const [movedEmployee] = employees.splice(draggedEmployeeIndex, 1);
                employees.splice(newIndex > draggedEmployeeIndex ? newIndex - 1 : newIndex, 0, movedEmployee);
                
                saveData();
                renderEmployeeList(); // Re-render to reflect the new order and update data-index attributes
                updateEmployeeSelects();
                updatePresentEmployeeCheckboxes();
                updateEmployeePairSelects();
            }
        }

        function handleDragEnd(e) {
            draggedItem.classList.remove('dragging');
            draggedItem = null;
            draggedEmployeeIndex = null;
            document.querySelectorAll('.list-item').forEach(item => {
                item.classList.remove('drag-over', 'drag-over-bottom');
            });
        }


        // --- Funktionen zum Hinzufügen, Löschen und Anzeigen von Arbeitsplätzen ---
        function addWorkplace() {
            const workplaceNameInput = document.getElementById('workplaceName');
            const name = workplaceNameInput.value.trim();
            if (name && !workplaces.includes(name)) {
                workplaces.push(name);
                renderWorkplaceList();
                updateWorkplaceSelects();
                updateLinkedWorkplaceSelects(); 
                workplaceNameInput.value = '';
                displayMessage('', 'info'); 
                saveData(); 
                updatePresentEmployeeCheckboxes(); 
            } else if (name && workplaces.includes(name)) {
                displayMessage('Arbeitsplatz "' + name + '" existiert bereits.', 'error');
            } else {
                displayMessage('Bitte eine gültige Arbeitsplatzbezeichnung eingeben.', 'error');
            }
        }

        function removeWorkplace(nameToRemove) {
            const isLinked = linkedWorkplaces.some(link => link.includes(nameToRemove));
            if (isLinked) {
                displayMessage(`Fehler: Arbeitsplatz "${nameToRemove}" ist Teil einer Verknüpfung und kann nicht gelöscht werden. Entfernen Sie zuerst die Verknüpfung im Admin-Menü.`, 'error');
                return;
            }

            workplaces = workplaces.filter(wp => wp !== nameToRemove);
            
            for (const emp in employeeSkills) {
                employeeSkills[emp] = employeeSkills[emp].filter(skill => skill !== nameToRemove);
            }
            for (const day in allDailySchedules) {
                for (const rotation in allDailySchedules[day]) {
                    delete allDailySchedules[day][rotation][nameToRemove];
                }
            }

            renderWorkplaceList();
            updateWorkplaceSelects();
            updateLinkedWorkplaceSelects(); 
            displayEmployeeSkills(); 
            displayMessage(`Arbeitsplatz "${nameToRemove}" wurde entfernt.`, 'info');
            saveData(); 
            updatePresentEmployeeCheckboxes(); 
        }

        function renderWorkplaceList() {
            const workplaceListDiv = document.getElementById('workplaceList');
            workplaceListDiv.innerHTML = workplaces.length === 0 ? 'Noch keine Arbeitsplätze hinzugefügt.' : '';
            workplaces.forEach((wp, index) => {
                const div = document.createElement('div');
                div.className = 'list-item';
                div.draggable = true; // Make draggable
                div.dataset.index = index; // Store original index
                div.id = 'workplace-' + wp.replace(/\s/g, '-'); // Unique ID for drag-drop

                div.innerHTML = `<span>${wp}</span><button class="remove-btn" onclick="removeWorkplace('${wp}')">X</button>`;

                // Add drag-and-drop event listeners for workplaces
                div.addEventListener('dragstart', handleWorkplaceDragStart);
                div.addEventListener('dragover', handleWorkplaceDragOver);
                div.addEventListener('dragleave', handleWorkplaceDragLeave);
                div.addEventListener('drop', handleWorkplaceDrop);
                div.addEventListener('dragend', handleWorkplaceDragEnd);

                workplaceListDiv.appendChild(div);
            });
        }

        // --- Functions for Drag and Drop (Workplaces) ---
        let draggedWorkplaceIndex = null;

        function handleWorkplaceDragStart(e) {
            draggedItem = e.target;
            draggedWorkplaceIndex = parseInt(draggedItem.dataset.index);
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', draggedItem.innerHTML); // Required for Firefox
            
            setTimeout(() => {
                draggedItem.classList.add('dragging');
            }, 0);
        }

        function handleWorkplaceDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            if (e.target.classList.contains('list-item') && e.target !== draggedItem) {
                const rect = e.target.getBoundingClientRect();
                const offsetY = e.clientY - rect.top;
                if (offsetY < rect.height / 2) {
                    e.target.classList.add('drag-over');
                    e.target.classList.remove('drag-over-bottom');
                } else {
                    e.target.classList.add('drag-over-bottom');
                    e.target.classList.remove('drag-over');
                }
            }
        }

        function handleWorkplaceDragLeave(e) {
            e.target.classList.remove('drag-over', 'drag-over-bottom');
        }

        function handleWorkplaceDrop(e) {
            e.preventDefault();
            e.target.classList.remove('drag-over', 'drag-over-bottom');

            if (e.target.classList.contains('list-item') && e.target !== draggedItem) {
                const targetWorkplaceIndex = parseInt(e.target.dataset.index);
                const rect = e.target.getBoundingClientRect();
                const offsetY = e.clientY - rect.top;
                let newIndex = targetWorkplaceIndex;

                if (offsetY > rect.height / 2) {
                    newIndex++;
                }
                
                if (draggedWorkplaceIndex === null) return;

                const [movedWorkplace] = workplaces.splice(draggedWorkplaceIndex, 1);
                workplaces.splice(newIndex > draggedWorkplaceIndex ? newIndex - 1 : newIndex, 0, movedWorkplace);
                
                saveData();
                renderWorkplaceList();
                updateWorkplaceSelects();
                updateLinkedWorkplaceSelects();
                displayEmployeeSkills(); // Re-render skills display if a workplace was selected
            }
        }

        function handleWorkplaceDragEnd(e) {
            draggedItem.classList.remove('dragging');
            draggedItem = null;
            draggedWorkplaceIndex = null;
            document.querySelectorAll('.list-item').forEach(item => {
                item.classList.remove('drag-over', 'drag-over-bottom');
            });
        }


        // --- Funktionen für die Zuweisung von Fähigkeiten ---
        function updateEmployeeSelects() {
            const selectEmployee = document.getElementById('selectEmployeeForSkills');
            selectEmployee.innerHTML = '<option value="">-- Mitarbeiter auswählen --</option>';
            employees.forEach(emp => {
                const option = document.createElement('option');
                option.value = emp;
                option.textContent = emp;
                selectEmployee.appendChild(option);
            });
        }

        function updateWorkplaceSelects() {
            const selectWorkplaces = document.getElementById('selectWorkplacesForSkills');
            selectWorkplaces.innerHTML = '';
            document.getElementById('selectWorkplacesForSkills').size = Math.min(Math.max(workplaces.length, 4), 10);
            workplaces.forEach(wp => {
                const option = document.createElement('option');
                option.value = wp;
                option.textContent = wp;
                selectWorkplaces.appendChild(option);
            });
        }

        function displayEmployeeSkills() {
            const selectedEmployee = document.getElementById('selectEmployeeForSkills').value;
            const currentEmployeeSkillsDiv = document.getElementById('currentEmployeeSkills');
            currentEmployeeSkillsDiv.innerHTML = '';

            if (selectedEmployee && employeeSkills[selectedEmployee]) {
                if (employeeSkills[selectedEmployee].length > 0) {
                    employeeSkills[selectedEmployee].forEach(skill => {
                        const div = document.createElement('div');
                        div.className = 'list-item';
                        div.textContent = skill;
                        currentEmployeeSkillsDiv.appendChild(div);
                    });
                } else {
                    currentEmployeeSkillsDiv.textContent = 'Dieser Mitarbeiter hat noch keine zugewiesenen Fähigkeiten.';
                }
                const selectWorkplaces = document.getElementById('selectWorkplacesForSkills');
                Array.from(selectWorkplaces.options).forEach(option => {
                    option.selected = employeeSkills[selectedEmployee].includes(option.value);
                });
            } else {
                currentEmployeeSkillsDiv.textContent = 'Bitte einen Mitarbeiter auswählen.';
            }
        }

        function assignSkills() {
            const selectedEmployee = document.getElementById('selectEmployeeForSkills').value;
            const selectedWorkplaces = Array.from(document.getElementById('selectWorkplacesForSkills').selectedOptions).map(option => option.value);

            if (selectedEmployee) {
                employeeSkills[selectedEmployee] = selectedWorkplaces;
                displayEmployeeSkills(); 
                displayMessage(`Fähigkeiten für ${selectedEmployee} aktualisiert.`, 'info');
                saveData(); 
            } else {
                displayMessage('Bitte einen Mitarbeiter auswählen, dem Fähigkeiten zugewiesen werden sollen.', 'error');
            }
        }

        // --- Funktion: Checkboxen für ANWESENDE Mitarbeiter aktualisieren ---
        function updatePresentEmployeeCheckboxes() {
            const presentEmployeesDiv = document.getElementById('presentEmployeesCheckboxes');
            presentEmployeesDiv.innerHTML = ''; 

            if (employees.length === 0) {
                presentEmployeesDiv.textContent = 'Bitte zuerst Mitarbeiter hinzufügen.';
                return;
            }

            employees.forEach(emp => {
                const label = document.createElement('label');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.name = 'presentEmployee';
                checkbox.value = emp;
                checkbox.checked = false; 
                checkbox.addEventListener('change', updateSelectedEmployeeCount); 
                
                const span = document.createElement('span');
                span.textContent = emp;
                
                label.appendChild(checkbox);
                label.appendChild(span); 
                presentEmployeesDiv.appendChild(label);
            });
            updateSelectedEmployeeCount(); 
        }

        // --- Funktion: Anzahl der ausgewählten Mitarbeiter aktualisieren und Checkboxen verwalten ---
        function updateSelectedEmployeeCount() {
            const presentCheckboxes = document.querySelectorAll('#presentEmployeesCheckboxes input[name="presentEmployee"]');
            const selectedCount = Array.from(presentCheckboxes).filter(cb => cb.checked).length;
            const requiredEmployees = workplaces.length; 

            const countDisplay = document.getElementById('selectedEmployeeCount');
            if (requiredEmployees === 0) {
                countDisplay.textContent = `Bitte Arbeitsplätze erstellen, um die benötigte Mitarbeiteranzahl zu sehen.`;
            } else {
                countDisplay.textContent = `Ausgewählte Mitarbeiter: ${selectedCount} von ${requiredEmployees} (benötigt)`;
            }
            
            manageEmployeeCheckboxes(selectedCount, requiredEmployees);
        }

        // --- Checkboxen basierend auf Auswahl verwalten (deaktivieren/aktivieren) ---
        function manageEmployeeCheckboxes(selectedCount, requiredEmployees) {
            const presentCheckboxes = document.querySelectorAll('#presentEmployeesCheckboxes input[name="presentEmployee"]');

            if (selectedCount >= requiredEmployees && requiredEmployees > 0) { 
                presentCheckboxes.forEach(cb => {
                    if (!cb.checked) {
                        cb.disabled = true; 
                    }
                });
            } else {
                presentCheckboxes.forEach(cb => {
                    cb.disabled = false; 
                });
            }
        }

        // --- Hilfsfunktion: Ermittelt den vorhergehenden Tag ---
        function getPreviousDay(currentDay) {
            const days = ['Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'];
            const currentIndex = days.indexOf(currentDay);
            if (currentIndex > 0) {
                return days[currentIndex - 1];
            }
            return null; 
        }

        // --- HILFSFUNKTION: Array zufällig mischen (Fisher-Yates Shuffle) ---
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]]; 
            }
        }

        // --- Funktion zur Generierung des Schichtplans ---
        function generateSchedule(startRotationIndex = 0) {
            const scheduleOutputDiv = document.getElementById('scheduleOutput');
            
            if (startRotationIndex === 0) {
                scheduleOutputDiv.innerHTML = ''; 
                document.getElementById('printScheduleBtn').style.display = 'none'; 
                displayMessage('', 'info'); 
                displayMessage('', 'error'); 
            }

            try {
                const dayOfWeek = document.getElementById('dayOfWeek').value;
                const presentCheckboxes = document.querySelectorAll('#presentEmployeesCheckboxes input[name="presentEmployee"]:checked');
                const initialAvailableEmployeesForDay = Array.from(presentCheckboxes).map(cb => cb.value); 

                const maxWorkplaceRepeats = parseInt(document.getElementById('maxWorkplaceRepeats').value, 10);

                if (workplaces.length === 0) {
                    displayMessage(`Fehler: Bitte erfasse mindestens einen Arbeitsplatz, um einen Plan zu erstellen.`, 'error');
                    return;
                }
                
                if (isNaN(maxWorkplaceRepeats) || maxWorkplaceRepeats < 1 || maxWorkplaceRepeats > 4) {
                    displayMessage('Fehler: Ungültiger Wert für "Max. Wiederholungen". Bitte geben Sie eine Zahl zwischen 1 und 4 ein.', 'error');
                    return;
                }

                if (initialAvailableEmployeesForDay.length !== workplaces.length) {
                    displayMessage(`Fehler: Es wurden ${initialAvailableEmployeesForDay.length} Mitarbeiter ausgewählt. Es müssen genau ${workplaces.length} Mitarbeiter ausgewählt werden, um alle Arbeitsplätze zu besetzen.`, 'error');
                    return;
                }
                
                const employeesWithoutSkills = initialAvailableEmployeesForDay.filter(emp => !employeeSkills[emp] || employeeSkills[emp].length === 0);
                if (employeesWithoutSkills.length > 0) {
                    displayMessage(`Fehler: Folgende ausgewählte Mitarbeiter haben noch keine Fähigkeiten zugewiesen: ${employeesWithoutSkills.join(', ')}. Bitte weisen Sie Fähigkeiten zu.`, 'error');
                    return;
                }

                const invalidLinkedWorkplaces = linkedWorkplaces.filter(link => 
                    !workplaces.includes(link[0]) || !workplaces.includes(link[1])
                );
                if (invalidLinkedWorkplaces.length > 0) {
                    displayMessage(`Fehler: Einige verknüpfte Arbeitsplätze existieren nicht mehr oder wurden umbenannt. Bitte prüfen Sie die Verknüpfungen im Admin-Menü.`, 'error');
                    return;
                }

                const rotations = ['1. Runde', '2. Runde', '3. Runde', '4. Runde'];
                if (!allDailySchedules[dayOfWeek] || startRotationIndex === 0) {
                    allDailySchedules[dayOfWeek] = {};
                    rotations.forEach(r => allDailySchedules[dayOfWeek][r] = {});
                }

                let employeeWorkplaceCounts = {}; 
                let employeeLastWorkplace = {}; 
                let employeePairDailyCounts = {}; 

                initialAvailableEmployeesForDay.forEach(emp => {
                    employeeWorkplaceCounts[emp] = {};
                    workplaces.forEach(wp => {
                        employeeWorkplaceCounts[emp][wp] = 0;
                    });
                    employeeLastWorkplace[emp] = null;
                });

                employeePairs.forEach(pairObj => {
                    const sortedPairKey = pairObj.pair.sort().join('_');
                    employeePairDailyCounts[sortedPairKey] = 0;
                });

                let overallOptimalSchedule = true; 

                const previousDay = getPreviousDay(dayOfWeek);
                const previousDaySchedule = allDailySchedules[previousDay] ? allDailySchedules[previousDay]['1. Runde'] : null;

                for (let r = 0; r < startRotationIndex; r++) {
                    const currentRotationName = rotations[r];
                    const manualAssignments = allDailySchedules[dayOfWeek][currentRotationName];
                    
                    for (const wp in manualAssignments) {
                        const emp = manualAssignments[wp];
                        if (emp && emp !== 'N/A' && emp !== 'UNPLANBAR' && employees.includes(emp)) {
                            if (!employeeWorkplaceCounts[emp]) {
                                employeeWorkplaceCounts[emp] = {};
                            }
                            if (!employeeWorkplaceCounts[emp][wp]) {
                                employeeWorkplaceCounts[emp][wp] = 0;
                            }
                            employeeWorkplaceCounts[emp][wp]++;
                            employeeLastWorkplace[emp] = wp;

                            employeePairs.forEach(pairObj => {
                                const sortedPairKey = pairObj.pair.sort().join('_');
                                if (pairObj.pair.includes(emp)) {
                                    const otherEmpInPair = pairObj.pair.find(e => e !== emp);
                                    if (manualAssignments[workplaces.find(w => manualAssignments[w] === otherEmpInPair)]) {
                                        employeePairDailyCounts[sortedPairKey]++;
                                    }
                                }
                            });
                        }
                    }
                }

                for (let i = startRotationIndex; i < rotations.length; i++) { 
                    const currentRotation = rotations[i];
                    let rotationAssignments = {};
                    
                    if (i < startRotationIndex && allDailySchedules[dayOfWeek][currentRotation]) {
                        rotationAssignments = {...allDailySchedules[dayOfWeek][currentRotation]};
                    } else {
                        workplaces.forEach(wp => rotationAssignments[wp] = 'N/A');
                    }

                    let currentRoundEmployeePool = [...initialAvailableEmployeesForDay]; 
                    
                    for (const wp in rotationAssignments) {
                        const assignedEmp = rotationAssignments[wp];
                        if (assignedEmp && assignedEmp !== 'N/A' && currentRoundEmployeePool.includes(assignedEmp)) {
                            currentRoundEmployeePool = currentRoundEmployeePool.filter(e => e !== assignedEmp);
                        }
                    }

                    let workplacesToAssign = [...workplaces].filter(wp => !rotationAssignments[wp] || rotationAssignments[wp] === 'N/A');

                    let unassignedLinkedWorkplaces = [...linkedWorkplaces].filter(link => 
                        workplacesToAssign.includes(link[0]) && workplacesToAssign.includes(link[1])
                    );

                    let remainingEmployeePairs = [...employeePairs].sort((a, b) => {
                        const keyA = a.pair.sort().join('_');
                        const keyB = b.pair.sort().join('_');
                        return employeePairDailyCounts[keyA] - employeePairDailyCounts[keyB]; 
                    });

                    shuffleArray(unassignedLinkedWorkplaces);

                    for (const link of unassignedLinkedWorkplaces) {
                        const wp1 = link[0];
                        const wp2 = link[1];
                        let assignedToLinked = false;
                        
                        if (rotationAssignments[wp1] && rotationAssignments[wp1] !== 'N/A' || rotationAssignments[wp2] && rotationAssignments[wp2] !== 'N/A') {
                            continue;
                        }

                        for (const pairObj of remainingEmployeePairs) {
                            const p1 = pairObj.pair[0];
                            const p2 = pairObj.pair[1];
                            const sortedPairKey = pairObj.pair.sort().join('_');

                            const bothAvailableInPool = currentRoundEmployeePool.includes(p1) && currentRoundEmployeePool.includes(p2);
                            
                            if (!bothAvailableInPool) {
                                continue; 
                            }

                            const p1_qual_wp1 = employeeSkills[p1].includes(wp1);
                            const p1_qual_wp2 = employeeSkills[p1].includes(wp2);
                            const p2_qual_wp1 = employeeSkills[p2].includes(wp1);
                            const p2_qual_wp2 = employeeSkills[p2].includes(wp2);
                            
                            const pairCanCoverWorkplaces = 
                                (p1_qual_wp1 && p2_qual_wp2) || (p1_qual_wp2 && p2_qual_wp1);
                            
                            if (pairCanCoverWorkplaces) {
                                if (employeePairDailyCounts[sortedPairKey] < pairObj.maxDailyPairings) {
                                    let employee1_candidate = null;
                                    let employee2_candidate = null;

                                    if (p1_qual_wp1 && p2_qual_wp1) { 
                                        if (rotationAssignments[wp1] === p1 && rotationAssignments[wp2] === p2) {
                                            employee1_candidate = p1;
                                            employee2_candidate = p2;
                                        } else if (rotationAssignments[wp1] === p2 && rotationAssignments[wp2] === p1) {
                                            employee1_candidate = p2;
                                            employee2_candidate = p1;
                                        } else { 
                                            employee1_candidate = p1;
                                            employee2_candidate = p2;
                                        }
                                    }
                                    if (p1_qual_wp1 && p2_qual_wp2) {
                                        employee1_candidate = p1;
                                        employee2_candidate = p2;
                                    } else if (p1_qual_wp2 && p2_qual_wp1) { 
                                        employee1_candidate = p2;
                                        employee2_candidate = p1;
                                    }

                                    if (employee1_candidate && employee2_candidate) {
                                        rotationAssignments[wp1] = employee1_candidate;
                                        rotationAssignments[wp2] = employee2_candidate;
                                        
                                        currentRoundEmployeePool = currentRoundEmployeePool.filter(emp => emp !== employee1_candidate && emp !== employee2_candidate);
                                        
                                        employeeWorkplaceCounts[employee1_candidate][wp1]++;
                                        employeeWorkplaceCounts[employee2_candidate][wp2]++;
                                        employeeLastWorkplace[employee1_candidate] = wp1;
                                        employeeLastWorkplace[employee2_candidate] = wp2;
                                        employeePairDailyCounts[sortedPairKey]++;
                                        assignedToLinked = true;
                                        break; 
                                    }
                                }
                            }
                        }

                        if (assignedToLinked) {
                            workplacesToAssign = workplacesToAssign.filter(w => w !== wp1 && w !== wp2);
                        } else {
                            overallOptimalSchedule = false; 
                        }
                    }

                    let remainingWorkplacesToAssign = [...workplacesToAssign].filter(wp => !rotationAssignments[wp] || rotationAssignments[wp] === 'N/A');

                    let currentWorkplacesWithCandidates = remainingWorkplacesToAssign.map(wp => { 
                        return {
                            name: wp,
                            qualifiedAndAvailable: currentRoundEmployeePool.filter(emp => 
                                employeeSkills[emp].includes(wp)
                            )
                        };
                    });

                    currentWorkplacesWithCandidates.sort((a, b) => {
                        const a_count = a.qualifiedAndAvailable.length;
                        const b_count = b.qualifiedAndAvailable.length;
                        return a_count - b_count;
                    });
                    
                    for (const workplaceObj of currentWorkplacesWithCandidates) {
                        const currentWorkplace = workplaceObj.name;
                        let assigned = false;

                        let currentEligibleEmployees = workplaceObj.qualifiedAndAvailable.filter(emp => currentRoundEmployeePool.includes(emp));
                        
                        shuffleArray(currentEligibleEmployees); 

                        let optimalCandidates = [...currentEligibleEmployees].sort((a, b) => {
                            const a_consecutive_score = (employeeLastWorkplace[a] === currentWorkplace) ? 1 : 0;
                            const b_consecutive_score = (employeeLastWorkplace[b] === currentWorkplace) ? 1 : 0;
                            if (a_consecutive_score !== b_consecutive_score) {
                                return a_consecutive_score - b_consecutive_score;
                            }

                            const a_repeats = employeeWorkplaceCounts[a][currentWorkplace];
                            const b_repeats = employeeWorkplaceCounts[b][currentWorkplace];
                            if (a_repeats !== b_repeats) {
                                return a_repeats - b_repeats;
                            }
                            
                            if (i === 0 && previousDaySchedule) { 
                                const a_was_at_same_wp_prev_day = (previousDaySchedule[currentWorkplace] === a) ? 1 : 0;
                                const b_was_at_same_wp_prev_day = (previousDaySchedule[currentWorkplace] === b) ? 1 : 0;
                                if (a_was_at_same_wp_prev_day !== b_was_at_same_wp_prev_day) {
                                    return a_was_at_same_wp_prev_day - b_was_at_same_wp_prev_day;
                                }
                            }

                            const a_unique_workplaces = Object.values(employeeWorkplaceCounts[a]).filter(count => count > 0).length;
                            const b_unique_workplaces = Object.values(employeeWorkplaceCounts[b]).filter(count => count > 0).length;
                            return b_unique_workplaces - a_unique_workplaces; 
                        });

                        for (const emp of optimalCandidates) {
                            if (currentRoundEmployeePool.includes(emp)) { 
                                if (employeeWorkplaceCounts[emp][currentWorkplace] < maxWorkplaceRepeats) {
                                    rotationAssignments[currentWorkplace] = emp;
                                    currentRoundEmployeePool = currentRoundEmployeePool.filter(e => e !== emp); 
                                    employeeWorkplaceCounts[emp][currentWorkplace]++;
                                    employeeLastWorkplace[emp] = currentWorkplace;
                                    assigned = true;
                                    break;
                                } else {
                                    overallOptimalSchedule = false; 
                                }
                            }
                        }

                        if (!assigned) {
                            overallOptimalSchedule = false; 
                            for (const emp of currentEligibleEmployees) { 
                                if (currentRoundEmployeePool.includes(emp)) { 
                                    rotationAssignments[currentWorkplace] = emp;
                                    currentRoundEmployeePool = currentRoundEmployeePool.filter(e => e !== emp);
                                    employeeWorkplaceCounts[emp][currentWorkplace]++;
                                    employeeLastWorkplace[emp] = currentWorkplace;
                                    assigned = true;
                                    break;
                                }
                            }
                        }

                        if (!assigned) {
                            rotationAssignments[currentWorkplace] = 'UNPLANBAR';
                            displayMessage(`Kritischer Fehler: Arbeitsplatz "${currentWorkplace}" konnte nicht besetzt werden. Es gibt keine qualifizierten Mitarbeiter mehr, die in dieser Runde zugewiesen werden können.`, 'error');
                            overallOptimalSchedule = false;
                        }
                    }
                    allDailySchedules[dayOfWeek][currentRotation] = rotationAssignments;
                }

                saveData(); // Speichert das Ergebnis online
                if (startRotationIndex === 0) {
                    displayMessage('Schichtplan erfolgreich generiert und online gespeichert!', 'info');
                } else {
                    displayMessage(`Runden ${rotations[startRotationIndex]} bis ${rotations[rotations.length - 1]} neu generiert und gespeichert!`, 'info');
                }

                renderScheduleTable(dayOfWeek);
                document.getElementById('printScheduleBtn').style.display = 'block';

            } catch (error) {
                console.error("Fehler bei der Schichtplanerstellung:", error);
                displayMessage(`Ein unerwarteter Fehler ist aufgetreten: ${error.message}.`, 'error');
                document.getElementById('printScheduleBtn').style.display = 'none';
            }
        }

        function renderScheduleTable(day) {
            const scheduleOutputDiv = document.getElementById('scheduleOutput');
            scheduleOutputDiv.innerHTML = ''; 

            const header = document.createElement('h2');
            header.textContent = `Schichtplan für ${day}`;
            scheduleOutputDiv.appendChild(header);

            const table = document.createElement('table');
            table.className = 'schedule-table';
            const thead = document.createElement('thead');
            const tbody = document.createElement('tbody');

            let headerRow = document.createElement('tr');
            let thCorner = document.createElement('th');
            thCorner.textContent = 'Arbeitsplatz';
            headerRow.appendChild(thCorner);
            const rotations = ['1. Runde', '2. Runde', '3. Runde', '4. Runde'];
            rotations.forEach(round => {
                let th = document.createElement('th');
                th.textContent = round;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            workplaces.forEach(wp => {
                let row = document.createElement('tr');
                let tdWorkplace = document.createElement('td');
                tdWorkplace.textContent = wp;
                row.appendChild(tdWorkplace);

                rotations.forEach((rotation, index) => {
                    let td = document.createElement('td');
                    td.textContent = (allDailySchedules[day] && allDailySchedules[day][rotation] && allDailySchedules[day][rotation][wp]) || 'N/A';
                    td.setAttribute('contenteditable', 'true');
                    td.dataset.rotation = rotation;
                    td.dataset.workplace = wp;
                    td.dataset.day = day;

                    td.addEventListener('blur', function() {
                        const editedDay = this.dataset.day;
                        const editedRotation = this.dataset.rotation;
                        const editedWorkplace = this.dataset.workplace;
                        const newValue = this.textContent.trim();
                        
                        if (newValue !== '') {
                            allDailySchedules[editedDay][editedRotation][editedWorkplace] = newValue;
                            saveData();
                            displayMessage('Manuelle Änderung gespeichert!', 'info');
                            
                            const editedRotationIndex = rotations.indexOf(editedRotation);
                            if (editedRotationIndex < rotations.length -1) { 
                                generateSchedule(editedRotationIndex + 1); 
                            } else {
                                renderScheduleTable(document.getElementById('dayOfWeek').value);
                            }
                        } else {
                            this.textContent = 'N/A';
                            allDailySchedules[editedDay][editedRotation][editedWorkplace] = 'N/A';
                            saveData();
                            displayMessage('Manuelle Änderung gespeichert!', 'info');
                            const editedRotationIndex = rotations.indexOf(editedRotation);
                            if (editedRotationIndex < rotations.length -1) { 
                                generateSchedule(editedRotationIndex + 1); 
                            } else {
                                renderScheduleTable(document.getElementById('dayOfWeek').value);
                            }
                        }
                    });
                    row.appendChild(td);
                });
                tbody.appendChild(row);
            });
            table.appendChild(tbody);
            scheduleOutputDiv.appendChild(table);

            const allTds = document.querySelectorAll('.schedule-table td[data-day]');
            allTds.forEach(td => {
                const day = td.dataset.day;
                const rotation = td.dataset.rotation;
                const employeeName = td.textContent.trim();
                checkAndColorCell(td, employeeName, rotation, day);
            });
        }


        // --- Funktion zur Überprüfung und Einfärbung von Zellen ---
        function checkAndColorCell(cellElement, employeeName, rotation, day) {
            cellElement.classList.remove('error-duplicate', 'warn-skill', 'warn-unknown', 'auto-compromise');
            cellElement.style.backgroundColor = ''; 
            let cellWarnings = [];

            const workplace = cellElement.dataset.workplace;
            const currentRotationData = allDailySchedules[day][rotation];

            if (employeeName === 'UNPLANBAR') {
                cellWarnings.push('Konnte nicht automatisch geplant werden.');
                cellElement.classList.add('error-duplicate');
            } else if (employeeName === 'N/A') {
                // No special handling
            }
            else if (!employees.includes(employeeName)) {
                cellWarnings.push('Warnung: Mitarbeiter ist nicht registriert.');
                cellElement.classList.add('warn-unknown');
            }
            else if (employeeSkills[employeeName] && !employeeSkills[employeeName].includes(workplace)) {
                cellWarnings.push(`Warnung: ${employeeName} hat keine Fähigkeit für ${workplace}.`);
                cellElement.classList.add('warn-skill');
            }

            if (employeeName && employeeName !== 'N/A' && employeeName !== 'UNPLANBAR' && employees.includes(employeeName)) {
                let countInRotation = 0;
                for (const wpKey in currentRotationData) {
                    if (currentRotationData[wpKey] === employeeName) {
                        countInRotation++;
                    }
                }
                if (countInRotation > 1) {
                    cellWarnings.push(`Fehler: Dieser Mitarbeiter ist in dieser Runde mehrfach zugewiesen!`);
                    cellElement.classList.add('error-duplicate');
                }
            }

            for (const link of linkedWorkplaces) {
                const wp1 = link[0];
                const wp2 = link[1];

                if (workplace === wp1 || workplace === wp2) {
                    const emp1 = currentRotationData[wp1];
                    const emp2 = currentRotationData[wp2];

                    const areBothAssigned = (emp1 && emp1 !== 'N/A' && emp1 !== 'UNPLANBAR') && (emp2 && emp2 !== 'N/A' && emp2 !== 'UNPLANBAR');
                    const areBothUnassigned = (emp1 === 'N/A' || emp1 === 'UNPLANBAR') && (emp2 === 'N/A' || emp2 === 'UNPLANBAR');
                    const areSameEmployeeAtLinked = emp1 === emp2 && emp1 !== 'N/A' && emp1 !== 'UNPLANBAR';

                    if (!areBothAssigned && !areBothUnassigned) {
                        cellWarnings.push(`Warnung: Verknüpfte Arbeitsplätze ${wp1} und ${wp2} sind nicht korrekt zusammen besetzt.`);
                        cellElement.classList.add('warn-skill');
                    } else if (areSameEmployeeAtLinked) {
                        cellWarnings.push(`Fehler: Derselbe Mitarbeiter (${emp1}) an verknüpften Arbeitsplätzen ${wp1} und ${wp2}.`);
                        cellElement.classList.add('error-duplicate');
                    }
                }
            }
            
            cellElement.title = cellWarnings.join('\n');
            if (cellWarnings.length === 0) {
                cellElement.title = '';
            }
        }


        // --- Funktion zum Drucken des Schichtplans ---
        function printSchedule() {
            const scheduleOutputContent = document.getElementById('scheduleOutput').innerHTML;
            const dayOfWeek = document.getElementById('dayOfWeek').value;

            const printContent = `
                <html>
                <head>
                    <title>Schichtplan ${dayOfWeek}</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; }
                        h2 { color: #0056b3; text-align: center; margin-bottom: 20px;}
                        table { width: 100%; border-collapse: collapse; margin-top: 15px; }
                        th, td { border: 1px solid #ddd; padding: 10px; text-align: left; }
                        th { background-color: #e2f0ff; color: #0056b3; }
                        td { background-color: #fff; }
                        td[style*="background-color"] { -webkit-print-color-adjust: exact; color-adjust: exact; }
                        td.error-duplicate { background-color: #ff6666 !important; }
                        td.warn-skill { background-color: #ffaa00 !important; }
                        td.warn-unknown { background-color: #a0a0a0 !important; }
                        td.auto-compromise { background-color: #ffddaa !important; }
                        @page { margin: 1cm; }
                    </style>
                </head>
                <body>
                    ${scheduleOutputContent}
                </body>
                </html>
            `;

            const printWindow = window.open('', '_blank');
            printWindow.document.open();
            printWindow.document.write(printContent);
            printWindow.document.close();

            printWindow.onload = function() {
                printWindow.focus();
                printWindow.print();
            };
        }

        // --- Helper for displaying messages ---
        function displayMessage(message, type) {
            const errorMessageDiv = document.getElementById('errorMessage');
            const infoMessageDiv = document.getElementById('infoMessage');

            if (type === 'error') {
                errorMessageDiv.textContent = message;
                infoMessageDiv.textContent = '';
            } else if (type === 'info') {
                infoMessageDiv.textContent = message;
                errorMessageDiv.textContent = '';
            }
        }

        // Initialisierung: Daten beim Laden der Seite laden und UI aktualisieren
        document.addEventListener('DOMContentLoaded', () => {
            if(G_SCRIPT_URL === 'DEINE_APPS_SCRIPT_URL_HIER'){
                displayMessage('FEHLER: Bitte füge deine Google Apps Script URL in der HTML-Datei ein.', 'error');
                return;
            }
            loadData();
        });

        // --- Import/Export Funktionen ---
        function exportToJSON() {
            const dataToExport = {
                employees,
                workplaces,
                employeeSkills,
                allDailySchedules,
                linkedWorkplaces,
                employeePairs
            };

            const jsonStr = JSON.stringify(dataToExport, null, 2);
            const blob = new Blob([jsonStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.href = url;
            link.download = 'schichtplan-daten.json';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function importFromJSON(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    employees = importedData.employees || [];
                    workplaces = importedData.workplaces || [];
                    employeeSkills = importedData.employeeSkills || {};
                    allDailySchedules = importedData.allDailySchedules || {};
                    linkedWorkplaces = importedData.linkedWorkplaces || [];
                    employeePairs = importedData.employeePairs || [];

                    // UI aktualisieren UND direkt online speichern
                    saveData();
                    
                    renderEmployeeList();
                    renderWorkplaceList();
                    updateEmployeeSelects();
                    updateWorkplaceSelects();
                    updateLinkedWorkplaceSelects();
                    updateEmployeePairSelects();
                    updatePresentEmployeeCheckboxes();
                    renderLinkedWorkplaces();
                    renderEmployeePairs();

                    displayMessage('Daten erfolgreich importiert und online gespeichert.', 'info');
                } catch (error) {
                    displayMessage('Fehler beim Importieren der Datei: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        }
    </script>
</body>
</html>';

        let employees = [];
        let workplaces = [];
        let employeeSkills = {}; // { employeeName: [workplace1, workplace2], ... }
        let allDailySchedules = {}; // { 'Montag': { '1. Runde': { 'WP1': 'EmpA' } }, 'Dienstag': { ... } }
        let linkedWorkplaces = []; // [[wp1, wp2], [wp3, wp4]]
        let employeePairs = []; // [{ pair: ['Mitarbeiter A', 'Mitarbeiter B'], maxDailyPairings: 2 }]

        let draggedItem = null;

        // --- NEUE Funktionen zum Speichern und Laden der Daten über Google Apps Script ---
        async function saveData() {
            const dataPayload = {
                employees,
                workplaces,
                employeeSkills,
                allDailySchedules,
                linkedWorkplaces,
                employeePairs
            };

            displayMessage('Speichere Daten online...', 'info');

            try {
                const response = await fetch(G_SCRIPT_URL, {
                    method: 'POST',
                    mode: 'cors', // Wichtig für Cross-Origin-Anfragen
                    headers: {
                        'Content-Type': 'text/plain;charset=utf-8', // Apps Script erwartet text/plain für postData
                    },
                    body: JSON.stringify(dataPayload)
                });
                const result = await response.json();

                if (result.status === 'success') {
                    displayMessage('Daten erfolgreich online gespeichert!', 'info');
                } else {
                    throw new Error(result.message);
                }
            } catch (error) {
                console.error('Fehler beim Speichern:', error);
                displayMessage(`Fehler beim Speichern der Daten: ${error.message}`, 'error');
            }
        }

        async function loadData() {
            displayMessage('Lade Daten vom Server...', 'info');
            try {
                const response = await fetch(G_SCRIPT_URL);
                const data = await response.json();

                if (data) {
                    employees = data.employees || [];
                    workplaces = data.workplaces || [];
                    employeeSkills = data.employeeSkills || {};
                    allDailySchedules = data.allDailySchedules || {};
                    linkedWorkplaces = data.linkedWorkplaces || [];
                    employeePairs = data.employeePairs || [];
                }
                 displayMessage('Daten erfolgreich geladen.', 'info');
            } catch (error) {
                console.error('Fehler beim Laden der Daten:', error);
                displayMessage(`Konnte keine Daten laden. Eventuell ist es der erste Start. (${error.message})`, 'error');
            }
            
            // Komplette UI nach dem Laden aktualisieren
            renderEmployeeList();
            renderWorkplaceList();
            updateEmployeeSelects();
            updateWorkplaceSelects();
            updatePresentEmployeeCheckboxes();
            updateLinkedWorkplaceSelects();
            updateEmployeePairSelects();
            renderLinkedWorkplaces();
            renderEmployeePairs();
        }


        // --- Admin-Menü Funktionen ---
        function openAdminLogin() {
            document.getElementById('adminOverlay').style.display = 'flex';
            document.getElementById('adminLogin').style.display = 'block';
            document.getElementById('adminMenuContent').style.display = 'none';
            document.getElementById('adminUsername').value = '';
            document.getElementById('adminPassword').value = '';
            document.getElementById('adminLoginMessage').textContent = '';
        }

        function closeAdminMenu() {
            document.getElementById('adminOverlay').style.display = 'none';
        }

        function loginAdmin() {
            const username = document.getElementById('adminUsername').value;
            const password = document.getElementById('adminPassword').value;
            const loginMessageDiv = document.getElementById('adminLoginMessage');

            if (username === 'admin' && password === 'admin') {
                document.getElementById('adminLogin').style.display = 'none';
                document.getElementById('adminMenuContent').style.display = 'block';
                updateLinkedWorkplaceSelects();
                renderLinkedWorkplaces();
                updateEmployeePairSelects();
                renderEmployeePairs();
                loginMessageDiv.textContent = '';
            } else {
                loginMessageDiv.textContent = 'Falscher Benutzername oder Passwort.';
            }
        }

        // --- Arbeitsplatz-Verknüpfungs-Funktionen ---
        function updateLinkedWorkplaceSelects() {
            const selectWp1 = document.getElementById('selectWorkplace1');
            const selectWp2 = document.getElementById('selectWorkplace2');
            
            selectWp1.innerHTML = '<option value="">-- Arbeitsplatz 1 auswählen --</option>';
            selectWp2.innerHTML = '<option value="">-- Arbeitsplatz 2 auswählen --</option>';

            workplaces.forEach(wp => {
                const option1 = document.createElement('option');
                option1.value = wp;
                option1.textContent = wp;
                selectWp1.appendChild(option1);

                const option2 = document.createElement('option');
                option2.value = wp;
                option2.textContent = wp;
                selectWp2.appendChild(option2);
            });
        }

        function addWorkplaceLink() {
            const wp1 = document.getElementById('selectWorkplace1').value;
            const wp2 = document.getElementById('selectWorkplace2').value;
            const messageDiv = document.getElementById('linkedWorkplaceMessage');
            messageDiv.textContent = ''; 

            if (!wp1 || !wp2) {
                messageDiv.textContent = 'Bitte wählen Sie zwei Arbeitsplätze aus.';
                return;
            }
            if (wp1 === wp2) {
                messageDiv.textContent = 'Arbeitsplätze dürfen nicht identisch sein.';
                return;
            }

            const newLink = [wp1, wp2].sort(); 

            const alreadyLinked = linkedWorkplaces.some(link => 
                (link[0] === newLink[0] && link[1] === newLink[1])
            );

            if (alreadyLinked) {
                messageDiv.textContent = 'Diese Arbeitsplatz-Verknüpfung existiert bereits.';
                return;
            }

            const isAlreadyInAnotherLink = linkedWorkplaces.some(link => 
                link.includes(wp1) || link.includes(wp2)
            );

            if (isAlreadyInAnotherLink) {
                messageDiv.textContent = `Mindestens einer der Arbeitsplätze (${wp1} oder ${wp2}) ist bereits in einer anderen Verknüpfung enthalten. Ein Arbeitsplatz kann nur in einer Verknüpfung sein.`;
                return;
            }

            linkedWorkplaces.push(newLink);
            saveData();
            renderLinkedWorkplaces();
            messageDiv.textContent = `Verknüpfung "${wp1}" und "${wp2}" hinzugefügt.`;
            document.getElementById('selectWorkplace1').value = '';
            document.getElementById('selectWorkplace2').value = '';
        }

        function removeWorkplaceLink(index) {
            const removedLink = linkedWorkplaces.splice(index, 1);
            saveData();
            renderLinkedWorkplaces();
            document.getElementById('linkedWorkplaceMessage').textContent = `Verknüpfung "${removedLink[0][0]}" und "${removedLink[0][1]}" entfernt.`;
        }

        function renderLinkedWorkplaces() {
            const listDiv = document.getElementById('linkedWorkplacesList');
            listDiv.innerHTML = linkedWorkplaces.length === 0 ? 'Noch keine Arbeitsplätze verknüpft.' : '';

            linkedWorkplaces.forEach((link, index) => {
                const div = document.createElement('div');
                div.className = 'list-item';
                div.innerHTML = `<span>${link[0]} & <span style="font-weight: bold;">${link[1]}</span></span><button class="remove-btn-small" onclick="removeWorkplaceLink(${index})">X</button>`;
                listDiv.appendChild(div);
            });
        }

        // --- Mitarbeiter-Paar Verknüpfungs-Funktionen ---
        function updateEmployeePairSelects() {
            const selectEmp1 = document.getElementById('selectEmployee1');
            const selectEmp2 = document.getElementById('selectEmployee2');
            
            selectEmp1.innerHTML = '<option value="">-- Mitarbeiter 1 auswählen --</option>';
            selectEmp2.innerHTML = '<option value="">-- Mitarbeiter 2 auswählen --</option>';

            employees.forEach(emp => {
                const option1 = document.createElement('option');
                option1.value = emp;
                option1.textContent = emp;
                selectEmp1.appendChild(option1);

                const option2 = document.createElement('option');
                option2.value = emp;
                option2.textContent = emp;
                selectEmp2.appendChild(option2);
            });
        }

        function addEmployeePair() {
            const emp1 = document.getElementById('selectEmployee1').value;
            const emp2 = document.getElementById('selectEmployee2').value;
            const maxPairings = parseInt(document.getElementById('maxPairingsPerDay').value, 10);
            const messageDiv = document.getElementById('employeePairMessage');
            messageDiv.textContent = '';

            if (!emp1 || !emp2) {
                messageDiv.textContent = 'Bitte wählen Sie zwei Mitarbeiter aus.';
                return;
            }
            if (emp1 === emp2) {
                messageDiv.textContent = 'Mitarbeiter dürfen nicht identisch sein.';
                return;
            }

            const newPair = [emp1, emp2].sort(); 
            
            const alreadyPaired = employeePairs.some(p => 
                (p.pair[0] === newPair[0] && p.pair[1] === newPair[1])
            );

            if (alreadyPaired) {
                messageDiv.textContent = 'Dieses Mitarbeiter-Paar existiert bereits.';
                return;
            }

            const isAlreadyInAnotherPair = employeePairs.some(p => 
                p.pair.includes(emp1) || p.pair.includes(emp2)
            );
            if (isAlreadyInAnotherPair) {
                messageDiv.textContent = `Mindestens einer der Mitarbeiter (${emp1} oder ${emp2}) ist bereits in einem anderen Paar enthalten. Ein Mitarbeiter kann nur in einem bevorzugten Paar sein.`;
                return;
            }

            employeePairs.push({ pair: newPair, maxDailyPairings: maxPairings });
            saveData();
            renderEmployeePairs();
            messageDiv.textContent = `Mitarbeiter-Paar "${emp1}" und "${emp2}" hinzugefügt (max. ${maxPairings} Runden/Tag).`;
            document.getElementById('selectEmployee1').value = '';
            document.getElementById('selectEmployee2').value = '';
            document.getElementById('maxPairingsPerDay').value = '1'; 
        }

        function removeEmployeePair(index) {
            const removedPair = employeePairs.splice(index, 1);
            saveData();
            renderEmployeePairs();
            document.getElementById('employeePairMessage').textContent = `Mitarbeiter-Paar "${removedPair[0].pair[0]}" und "${removedPair[0].pair[1]}" entfernt.`;
        }

        function renderEmployeePairs() {
            const listDiv = document.getElementById('employeePairsList');
            listDiv.innerHTML = employeePairs.length === 0 ? 'Noch keine Mitarbeiter-Paare verknüpft.' : '';

            employeePairs.forEach((pairObj, index) => {
                const div = document.createElement('div');
                div.className = 'list-item employee-pair-item';
                div.innerHTML = `
                    <span>${pairObj.pair[0]} & <span style="font-weight: bold;">${pairObj.pair[1]}</span></span>
                    <select onchange="updateEmployeePairMaxPairings(${index}, this.value)">
                        <option value="1" ${pairObj.maxDailyPairings === 1 ? 'selected' : ''}>1 Runde</option>
                        <option value="2" ${pairObj.maxDailyPairings === 2 ? 'selected' : ''}>2 Runden</option>
                        <option value="3" ${pairObj.maxDailyPairings === 3 ? 'selected' : ''}>3 Runden</option>
                        <option value="4" ${pairObj.maxDailyPairings === 4 ? 'selected' : ''}>4 Runden</option>
                    </select>
                    <button class="remove-btn-small" onclick="removeEmployeePair(${index})">X</button>
                `;
                listDiv.appendChild(div);
            });
        }

        function updateEmployeePairMaxPairings(index, newValue) {
            employeePairs[index].maxDailyPairings = parseInt(newValue, 10);
            saveData();
            displayMessage('Maximale gemeinsame Runden aktualisiert.', 'info');
        }

        // --- Funktionen zum Hinzufügen und Anzeigen von Mitarbeitern ---
        function addEmployee() {
            const employeeNameInput = document.getElementById('employeeName');
            const name = employeeNameInput.value.trim();
            if (name && !employees.includes(name)) {
                employees.push(name);
                employeeSkills[name] = [];
                renderEmployeeList();
                updateEmployeeSelects();
                updatePresentEmployeeCheckboxes();
                updateEmployeePairSelects();
                employeeNameInput.value = '';
                displayMessage('', 'info'); 
                saveData(); 
            } else if (name && employees.includes(name)) {
                displayMessage('Mitarbeiter "' + name + '" existiert bereits.', 'error');
            } else {
                displayMessage('Bitte einen gültigen Mitarbeiternamen eingeben.', 'error');
            }
        }

        function removeEmployee(nameToRemove) {
            const isPaired = employeePairs.some(pairObj => pairObj.pair.includes(nameToRemove));
            if (isPaired) {
                displayMessage(`Fehler: Mitarbeiter "${nameToRemove}" ist Teil eines bevorzugten Paares und kann nicht gelöscht werden. Entfernen Sie zuerst das Paar im Admin-Menü.`, 'error');
                return;
            }

            employees = employees.filter(emp => emp !== nameToRemove);
            delete employeeSkills[nameToRemove]; 
            for (const day in allDailySchedules) {
                for (const rotation in allDailySchedules[day]) {
                    for (const workplace in allDailySchedules[day][rotation]) {
                        if (allDailySchedules[day][rotation][workplace] === nameToRemove) {
                            allDailySchedules[day][rotation][workplace] = 'N/A'; 
                        }
                    }
                }
            }
            renderEmployeeList();
            updateEmployeeSelects();
            updatePresentEmployeeCheckboxes();
            updateEmployeePairSelects();
            displayMessage(`Mitarbeiter "${nameToRemove}" wurde entfernt.`, 'info');
            saveData(); 
        }

        function renderEmployeeList() {
            const employeeListDiv = document.getElementById('employeeList');
            employeeListDiv.innerHTML = employees.length === 0 ? 'Noch keine Mitarbeiter hinzugefügt.' : '';
            employees.forEach((emp, index) => {
                const div = document.createElement('div');
                div.className = 'list-item';
                div.draggable = true; // Make draggable
                div.dataset.index = index; // Store original index
                div.id = 'employee-' + emp.replace(/\s/g, '-'); // Unique ID for drag-drop

                div.innerHTML = `<span>${emp}</span><button class="remove-btn" onclick="removeEmployee('${emp}')">X</button>`;
                
                // Add drag-and-drop event listeners
                div.addEventListener('dragstart', handleDragStart);
                div.addEventListener('dragover', handleDragOver);
                div.addEventListener('dragleave', handleDragLeave);
                div.addEventListener('drop', handleDrop);
                div.addEventListener('dragend', handleDragEnd);

                employeeListDiv.appendChild(div);
            });
        }

        // --- Functions for Drag and Drop (Employees) ---
        let draggedEmployeeIndex = null;

        function handleDragStart(e) {
            draggedItem = e.target;
            draggedEmployeeIndex = parseInt(draggedItem.dataset.index);
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', draggedItem.innerHTML); // Required for Firefox
            
            setTimeout(() => {
                draggedItem.classList.add('dragging');
            }, 0); // Add class after drag started to hide the original item immediately
        }

        function handleDragOver(e) {
            e.preventDefault(); // Necessary to allow dropping
            e.dataTransfer.dropEffect = 'move';
            if (e.target.classList.contains('list-item') && e.target !== draggedItem) {
                // Determine if dropping above or below
                const rect = e.target.getBoundingClientRect();
                const offsetY = e.clientY - rect.top;
                if (offsetY < rect.height / 2) {
                    e.target.classList.add('drag-over');
                    e.target.classList.remove('drag-over-bottom');
                } else {
                    e.target.classList.add('drag-over-bottom');
                    e.target.classList.remove('drag-over');
                }
            }
        }

        function handleDragLeave(e) {
            e.target.classList.remove('drag-over', 'drag-over-bottom');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.target.classList.remove('drag-over', 'drag-over-bottom');

            if (e.target.classList.contains('list-item') && e.target !== draggedItem) {
                const targetEmployeeIndex = parseInt(e.target.dataset.index);
                const rect = e.target.getBoundingClientRect();
                const offsetY = e.clientY - rect.top;
                let newIndex = targetEmployeeIndex;

                if (offsetY > rect.height / 2) {
                    newIndex++; // Drop below the target item
                }
                
                if (draggedEmployeeIndex === null) return; // Should not happen

                const [movedEmployee] = employees.splice(draggedEmployeeIndex, 1);
                employees.splice(newIndex > draggedEmployeeIndex ? newIndex - 1 : newIndex, 0, movedEmployee);
                
                saveData();
                renderEmployeeList(); // Re-render to reflect the new order and update data-index attributes
                updateEmployeeSelects();
                updatePresentEmployeeCheckboxes();
                updateEmployeePairSelects();
            }
        }

        function handleDragEnd(e) {
            draggedItem.classList.remove('dragging');
            draggedItem = null;
            draggedEmployeeIndex = null;
            document.querySelectorAll('.list-item').forEach(item => {
                item.classList.remove('drag-over', 'drag-over-bottom');
            });
        }


        // --- Funktionen zum Hinzufügen, Löschen und Anzeigen von Arbeitsplätzen ---
        function addWorkplace() {
            const workplaceNameInput = document.getElementById('workplaceName');
            const name = workplaceNameInput.value.trim();
            if (name && !workplaces.includes(name)) {
                workplaces.push(name);
                renderWorkplaceList();
                updateWorkplaceSelects();
                updateLinkedWorkplaceSelects(); 
                workplaceNameInput.value = '';
                displayMessage('', 'info'); 
                saveData(); 
                updatePresentEmployeeCheckboxes(); 
            } else if (name && workplaces.includes(name)) {
                displayMessage('Arbeitsplatz "' + name + '" existiert bereits.', 'error');
            } else {
                displayMessage('Bitte eine gültige Arbeitsplatzbezeichnung eingeben.', 'error');
            }
        }

        function removeWorkplace(nameToRemove) {
            const isLinked = linkedWorkplaces.some(link => link.includes(nameToRemove));
            if (isLinked) {
                displayMessage(`Fehler: Arbeitsplatz "${nameToRemove}" ist Teil einer Verknüpfung und kann nicht gelöscht werden. Entfernen Sie zuerst die Verknüpfung im Admin-Menü.`, 'error');
                return;
            }

            workplaces = workplaces.filter(wp => wp !== nameToRemove);
            
            for (const emp in employeeSkills) {
                employeeSkills[emp] = employeeSkills[emp].filter(skill => skill !== nameToRemove);
            }
            for (const day in allDailySchedules) {
                for (const rotation in allDailySchedules[day]) {
                    delete allDailySchedules[day][rotation][nameToRemove];
                }
            }

            renderWorkplaceList();
            updateWorkplaceSelects();
            updateLinkedWorkplaceSelects(); 
            displayEmployeeSkills(); 
            displayMessage(`Arbeitsplatz "${nameToRemove}" wurde entfernt.`, 'info');
            saveData(); 
            updatePresentEmployeeCheckboxes(); 
        }

        function renderWorkplaceList() {
            const workplaceListDiv = document.getElementById('workplaceList');
            workplaceListDiv.innerHTML = workplaces.length === 0 ? 'Noch keine Arbeitsplätze hinzugefügt.' : '';
            workplaces.forEach((wp, index) => {
                const div = document.createElement('div');
                div.className = 'list-item';
                div.draggable = true; // Make draggable
                div.dataset.index = index; // Store original index
                div.id = 'workplace-' + wp.replace(/\s/g, '-'); // Unique ID for drag-drop

                div.innerHTML = `<span>${wp}</span><button class="remove-btn" onclick="removeWorkplace('${wp}')">X</button>`;

                // Add drag-and-drop event listeners for workplaces
                div.addEventListener('dragstart', handleWorkplaceDragStart);
                div.addEventListener('dragover', handleWorkplaceDragOver);
                div.addEventListener('dragleave', handleWorkplaceDragLeave);
                div.addEventListener('drop', handleWorkplaceDrop);
                div.addEventListener('dragend', handleWorkplaceDragEnd);

                workplaceListDiv.appendChild(div);
            });
        }

        // --- Functions for Drag and Drop (Workplaces) ---
        let draggedWorkplaceIndex = null;

        function handleWorkplaceDragStart(e) {
            draggedItem = e.target;
            draggedWorkplaceIndex = parseInt(draggedItem.dataset.index);
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', draggedItem.innerHTML); // Required for Firefox
            
            setTimeout(() => {
                draggedItem.classList.add('dragging');
            }, 0);
        }

        function handleWorkplaceDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            if (e.target.classList.contains('list-item') && e.target !== draggedItem) {
                const rect = e.target.getBoundingClientRect();
                const offsetY = e.clientY - rect.top;
                if (offsetY < rect.height / 2) {
                    e.target.classList.add('drag-over');
                    e.target.classList.remove('drag-over-bottom');
                } else {
                    e.target.classList.add('drag-over-bottom');
                    e.target.classList.remove('drag-over');
                }
            }
        }

        function handleWorkplaceDragLeave(e) {
            e.target.classList.remove('drag-over', 'drag-over-bottom');
        }

        function handleWorkplaceDrop(e) {
            e.preventDefault();
            e.target.classList.remove('drag-over', 'drag-over-bottom');

            if (e.target.classList.contains('list-item') && e.target !== draggedItem) {
                const targetWorkplaceIndex = parseInt(e.target.dataset.index);
                const rect = e.target.getBoundingClientRect();
                const offsetY = e.clientY - rect.top;
                let newIndex = targetWorkplaceIndex;

                if (offsetY > rect.height / 2) {
                    newIndex++;
                }
                
                if (draggedWorkplaceIndex === null) return;

                const [movedWorkplace] = workplaces.splice(draggedWorkplaceIndex, 1);
                workplaces.splice(newIndex > draggedWorkplaceIndex ? newIndex - 1 : newIndex, 0, movedWorkplace);
                
                saveData();
                renderWorkplaceList();
                updateWorkplaceSelects();
                updateLinkedWorkplaceSelects();
                displayEmployeeSkills(); // Re-render skills display if a workplace was selected
            }
        }

        function handleWorkplaceDragEnd(e) {
            draggedItem.classList.remove('dragging');
            draggedItem = null;
            draggedWorkplaceIndex = null;
            document.querySelectorAll('.list-item').forEach(item => {
                item.classList.remove('drag-over', 'drag-over-bottom');
            });
        }


        // --- Funktionen für die Zuweisung von Fähigkeiten ---
        function updateEmployeeSelects() {
            const selectEmployee = document.getElementById('selectEmployeeForSkills');
            selectEmployee.innerHTML = '<option value="">-- Mitarbeiter auswählen --</option>';
            employees.forEach(emp => {
                const option = document.createElement('option');
                option.value = emp;
                option.textContent = emp;
                selectEmployee.appendChild(option);
            });
        }

        function updateWorkplaceSelects() {
            const selectWorkplaces = document.getElementById('selectWorkplacesForSkills');
            selectWorkplaces.innerHTML = '';
            document.getElementById('selectWorkplacesForSkills').size = Math.min(Math.max(workplaces.length, 4), 10);
            workplaces.forEach(wp => {
                const option = document.createElement('option');
                option.value = wp;
                option.textContent = wp;
                selectWorkplaces.appendChild(option);
            });
        }

        function displayEmployeeSkills() {
            const selectedEmployee = document.getElementById('selectEmployeeForSkills').value;
            const currentEmployeeSkillsDiv = document.getElementById('currentEmployeeSkills');
            currentEmployeeSkillsDiv.innerHTML = '';

            if (selectedEmployee && employeeSkills[selectedEmployee]) {
                if (employeeSkills[selectedEmployee].length > 0) {
                    employeeSkills[selectedEmployee].forEach(skill => {
                        const div = document.createElement('div');
                        div.className = 'list-item';
                        div.textContent = skill;
                        currentEmployeeSkillsDiv.appendChild(div);
                    });
                } else {
                    currentEmployeeSkillsDiv.textContent = 'Dieser Mitarbeiter hat noch keine zugewiesenen Fähigkeiten.';
                }
                const selectWorkplaces = document.getElementById('selectWorkplacesForSkills');
                Array.from(selectWorkplaces.options).forEach(option => {
                    option.selected = employeeSkills[selectedEmployee].includes(option.value);
                });
            } else {
                currentEmployeeSkillsDiv.textContent = 'Bitte einen Mitarbeiter auswählen.';
            }
        }

        function assignSkills() {
            const selectedEmployee = document.getElementById('selectEmployeeForSkills').value;
            const selectedWorkplaces = Array.from(document.getElementById('selectWorkplacesForSkills').selectedOptions).map(option => option.value);

            if (selectedEmployee) {
                employeeSkills[selectedEmployee] = selectedWorkplaces;
                displayEmployeeSkills(); 
                displayMessage(`Fähigkeiten für ${selectedEmployee} aktualisiert.`, 'info');
                saveData(); 
            } else {
                displayMessage('Bitte einen Mitarbeiter auswählen, dem Fähigkeiten zugewiesen werden sollen.', 'error');
            }
        }

        // --- Funktion: Checkboxen für ANWESENDE Mitarbeiter aktualisieren ---
        function updatePresentEmployeeCheckboxes() {
            const presentEmployeesDiv = document.getElementById('presentEmployeesCheckboxes');
            presentEmployeesDiv.innerHTML = ''; 

            if (employees.length === 0) {
                presentEmployeesDiv.textContent = 'Bitte zuerst Mitarbeiter hinzufügen.';
                return;
            }

            employees.forEach(emp => {
                const label = document.createElement('label');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.name = 'presentEmployee';
                checkbox.value = emp;
                checkbox.checked = false; 
                checkbox.addEventListener('change', updateSelectedEmployeeCount); 
                
                const span = document.createElement('span');
                span.textContent = emp;
                
                label.appendChild(checkbox);
                label.appendChild(span); 
                presentEmployeesDiv.appendChild(label);
            });
            updateSelectedEmployeeCount(); 
        }

        // --- Funktion: Anzahl der ausgewählten Mitarbeiter aktualisieren und Checkboxen verwalten ---
        function updateSelectedEmployeeCount() {
            const presentCheckboxes = document.querySelectorAll('#presentEmployeesCheckboxes input[name="presentEmployee"]');
            const selectedCount = Array.from(presentCheckboxes).filter(cb => cb.checked).length;
            const requiredEmployees = workplaces.length; 

            const countDisplay = document.getElementById('selectedEmployeeCount');
            if (requiredEmployees === 0) {
                countDisplay.textContent = `Bitte Arbeitsplätze erstellen, um die benötigte Mitarbeiteranzahl zu sehen.`;
            } else {
                countDisplay.textContent = `Ausgewählte Mitarbeiter: ${selectedCount} von ${requiredEmployees} (benötigt)`;
            }
            
            manageEmployeeCheckboxes(selectedCount, requiredEmployees);
        }

        // --- Checkboxen basierend auf Auswahl verwalten (deaktivieren/aktivieren) ---
        function manageEmployeeCheckboxes(selectedCount, requiredEmployees) {
            const presentCheckboxes = document.querySelectorAll('#presentEmployeesCheckboxes input[name="presentEmployee"]');

            if (selectedCount >= requiredEmployees && requiredEmployees > 0) { 
                presentCheckboxes.forEach(cb => {
                    if (!cb.checked) {
                        cb.disabled = true; 
                    }
                });
            } else {
                presentCheckboxes.forEach(cb => {
                    cb.disabled = false; 
                });
            }
        }

        // --- Hilfsfunktion: Ermittelt den vorhergehenden Tag ---
        function getPreviousDay(currentDay) {
            const days = ['Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'];
            const currentIndex = days.indexOf(currentDay);
            if (currentIndex > 0) {
                return days[currentIndex - 1];
            }
            return null; 
        }

        // --- HILFSFUNKTION: Array zufällig mischen (Fisher-Yates Shuffle) ---
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]]; 
            }
        }

        // --- Funktion zur Generierung des Schichtplans ---
        function generateSchedule(startRotationIndex = 0) {
            const scheduleOutputDiv = document.getElementById('scheduleOutput');
            
            if (startRotationIndex === 0) {
                scheduleOutputDiv.innerHTML = ''; 
                document.getElementById('printScheduleBtn').style.display = 'none'; 
                displayMessage('', 'info'); 
                displayMessage('', 'error'); 
            }

            try {
                const dayOfWeek = document.getElementById('dayOfWeek').value;
                const presentCheckboxes = document.querySelectorAll('#presentEmployeesCheckboxes input[name="presentEmployee"]:checked');
                const initialAvailableEmployeesForDay = Array.from(presentCheckboxes).map(cb => cb.value); 

                const maxWorkplaceRepeats = parseInt(document.getElementById('maxWorkplaceRepeats').value, 10);

                if (workplaces.length === 0) {
                    displayMessage(`Fehler: Bitte erfasse mindestens einen Arbeitsplatz, um einen Plan zu erstellen.`, 'error');
                    return;
                }
                
                if (isNaN(maxWorkplaceRepeats) || maxWorkplaceRepeats < 1 || maxWorkplaceRepeats > 4) {
                    displayMessage('Fehler: Ungültiger Wert für "Max. Wiederholungen". Bitte geben Sie eine Zahl zwischen 1 und 4 ein.', 'error');
                    return;
                }

                if (initialAvailableEmployeesForDay.length !== workplaces.length) {
                    displayMessage(`Fehler: Es wurden ${initialAvailableEmployeesForDay.length} Mitarbeiter ausgewählt. Es müssen genau ${workplaces.length} Mitarbeiter ausgewählt werden, um alle Arbeitsplätze zu besetzen.`, 'error');
                    return;
                }
                
                const employeesWithoutSkills = initialAvailableEmployeesForDay.filter(emp => !employeeSkills[emp] || employeeSkills[emp].length === 0);
                if (employeesWithoutSkills.length > 0) {
                    displayMessage(`Fehler: Folgende ausgewählte Mitarbeiter haben noch keine Fähigkeiten zugewiesen: ${employeesWithoutSkills.join(', ')}. Bitte weisen Sie Fähigkeiten zu.`, 'error');
                    return;
                }

                const invalidLinkedWorkplaces = linkedWorkplaces.filter(link => 
                    !workplaces.includes(link[0]) || !workplaces.includes(link[1])
                );
                if (invalidLinkedWorkplaces.length > 0) {
                    displayMessage(`Fehler: Einige verknüpfte Arbeitsplätze existieren nicht mehr oder wurden umbenannt. Bitte prüfen Sie die Verknüpfungen im Admin-Menü.`, 'error');
                    return;
                }

                const rotations = ['1. Runde', '2. Runde', '3. Runde', '4. Runde'];
                if (!allDailySchedules[dayOfWeek] || startRotationIndex === 0) {
                    allDailySchedules[dayOfWeek] = {};
                    rotations.forEach(r => allDailySchedules[dayOfWeek][r] = {});
                }

                let employeeWorkplaceCounts = {}; 
                let employeeLastWorkplace = {}; 
                let employeePairDailyCounts = {}; 

                initialAvailableEmployeesForDay.forEach(emp => {
                    employeeWorkplaceCounts[emp] = {};
                    workplaces.forEach(wp => {
                        employeeWorkplaceCounts[emp][wp] = 0;
                    });
                    employeeLastWorkplace[emp] = null;
                });

                employeePairs.forEach(pairObj => {
                    const sortedPairKey = pairObj.pair.sort().join('_');
                    employeePairDailyCounts[sortedPairKey] = 0;
                });

                let overallOptimalSchedule = true; 

                const previousDay = getPreviousDay(dayOfWeek);
                const previousDaySchedule = allDailySchedules[previousDay] ? allDailySchedules[previousDay]['1. Runde'] : null;

                for (let r = 0; r < startRotationIndex; r++) {
                    const currentRotationName = rotations[r];
                    const manualAssignments = allDailySchedules[dayOfWeek][currentRotationName];
                    
                    for (const wp in manualAssignments) {
                        const emp = manualAssignments[wp];
                        if (emp && emp !== 'N/A' && emp !== 'UNPLANBAR' && employees.includes(emp)) {
                            if (!employeeWorkplaceCounts[emp]) {
                                employeeWorkplaceCounts[emp] = {};
                            }
                            if (!employeeWorkplaceCounts[emp][wp]) {
                                employeeWorkplaceCounts[emp][wp] = 0;
                            }
                            employeeWorkplaceCounts[emp][wp]++;
                            employeeLastWorkplace[emp] = wp;

                            employeePairs.forEach(pairObj => {
                                const sortedPairKey = pairObj.pair.sort().join('_');
                                if (pairObj.pair.includes(emp)) {
                                    const otherEmpInPair = pairObj.pair.find(e => e !== emp);
                                    if (manualAssignments[workplaces.find(w => manualAssignments[w] === otherEmpInPair)]) {
                                        employeePairDailyCounts[sortedPairKey]++;
                                    }
                                }
                            });
                        }
                    }
                }

                for (let i = startRotationIndex; i < rotations.length; i++) { 
                    const currentRotation = rotations[i];
                    let rotationAssignments = {};
                    
                    if (i < startRotationIndex && allDailySchedules[dayOfWeek][currentRotation]) {
                        rotationAssignments = {...allDailySchedules[dayOfWeek][currentRotation]};
                    } else {
                        workplaces.forEach(wp => rotationAssignments[wp] = 'N/A');
                    }

                    let currentRoundEmployeePool = [...initialAvailableEmployeesForDay]; 
                    
                    for (const wp in rotationAssignments) {
                        const assignedEmp = rotationAssignments[wp];
                        if (assignedEmp && assignedEmp !== 'N/A' && currentRoundEmployeePool.includes(assignedEmp)) {
                            currentRoundEmployeePool = currentRoundEmployeePool.filter(e => e !== assignedEmp);
                        }
                    }

                    let workplacesToAssign = [...workplaces].filter(wp => !rotationAssignments[wp] || rotationAssignments[wp] === 'N/A');

                    let unassignedLinkedWorkplaces = [...linkedWorkplaces].filter(link => 
                        workplacesToAssign.includes(link[0]) && workplacesToAssign.includes(link[1])
                    );

                    let remainingEmployeePairs = [...employeePairs].sort((a, b) => {
                        const keyA = a.pair.sort().join('_');
                        const keyB = b.pair.sort().join('_');
                        return employeePairDailyCounts[keyA] - employeePairDailyCounts[keyB]; 
                    });

                    shuffleArray(unassignedLinkedWorkplaces);

                    for (const link of unassignedLinkedWorkplaces) {
                        const wp1 = link[0];
                        const wp2 = link[1];
                        let assignedToLinked = false;
                        
                        if (rotationAssignments[wp1] && rotationAssignments[wp1] !== 'N/A' || rotationAssignments[wp2] && rotationAssignments[wp2] !== 'N/A') {
                            continue;
                        }

                        for (const pairObj of remainingEmployeePairs) {
                            const p1 = pairObj.pair[0];
                            const p2 = pairObj.pair[1];
                            const sortedPairKey = pairObj.pair.sort().join('_');

                            const bothAvailableInPool = currentRoundEmployeePool.includes(p1) && currentRoundEmployeePool.includes(p2);
                            
                            if (!bothAvailableInPool) {
                                continue; 
                            }

                            const p1_qual_wp1 = employeeSkills[p1].includes(wp1);
                            const p1_qual_wp2 = employeeSkills[p1].includes(wp2);
                            const p2_qual_wp1 = employeeSkills[p2].includes(wp1);
                            const p2_qual_wp2 = employeeSkills[p2].includes(wp2);
                            
                            const pairCanCoverWorkplaces = 
                                (p1_qual_wp1 && p2_qual_wp2) || (p1_qual_wp2 && p2_qual_wp1);
                            
                            if (pairCanCoverWorkplaces) {
                                if (employeePairDailyCounts[sortedPairKey] < pairObj.maxDailyPairings) {
                                    let employee1_candidate = null;
                                    let employee2_candidate = null;

                                    if (p1_qual_wp1 && p2_qual_wp1) { 
                                        if (rotationAssignments[wp1] === p1 && rotationAssignments[wp2] === p2) {
                                            employee1_candidate = p1;
                                            employee2_candidate = p2;
                                        } else if (rotationAssignments[wp1] === p2 && rotationAssignments[wp2] === p1) {
                                            employee1_candidate = p2;
                                            employee2_candidate = p1;
                                        } else { 
                                            employee1_candidate = p1;
                                            employee2_candidate = p2;
                                        }
                                    }
                                    if (p1_qual_wp1 && p2_qual_wp2) {
                                        employee1_candidate = p1;
                                        employee2_candidate = p2;
                                    } else if (p1_qual_wp2 && p2_qual_wp1) { 
                                        employee1_candidate = p2;
                                        employee2_candidate = p1;
                                    }

                                    if (employee1_candidate && employee2_candidate) {
                                        rotationAssignments[wp1] = employee1_candidate;
                                        rotationAssignments[wp2] = employee2_candidate;
                                        
                                        currentRoundEmployeePool = currentRoundEmployeePool.filter(emp => emp !== employee1_candidate && emp !== employee2_candidate);
                                        
                                        employeeWorkplaceCounts[employee1_candidate][wp1]++;
                                        employeeWorkplaceCounts[employee2_candidate][wp2]++;
                                        employeeLastWorkplace[employee1_candidate] = wp1;
                                        employeeLastWorkplace[employee2_candidate] = wp2;
                                        employeePairDailyCounts[sortedPairKey]++;
                                        assignedToLinked = true;
                                        break; 
                                    }
                                }
                            }
                        }

                        if (assignedToLinked) {
                            workplacesToAssign = workplacesToAssign.filter(w => w !== wp1 && w !== wp2);
                        } else {
                            overallOptimalSchedule = false; 
                        }
                    }

                    let remainingWorkplacesToAssign = [...workplacesToAssign].filter(wp => !rotationAssignments[wp] || rotationAssignments[wp] === 'N/A');

                    let currentWorkplacesWithCandidates = remainingWorkplacesToAssign.map(wp => { 
                        return {
                            name: wp,
                            qualifiedAndAvailable: currentRoundEmployeePool.filter(emp => 
                                employeeSkills[emp].includes(wp)
                            )
                        };
                    });

                    currentWorkplacesWithCandidates.sort((a, b) => {
                        const a_count = a.qualifiedAndAvailable.length;
                        const b_count = b.qualifiedAndAvailable.length;
                        return a_count - b_count;
                    });
                    
                    for (const workplaceObj of currentWorkplacesWithCandidates) {
                        const currentWorkplace = workplaceObj.name;
                        let assigned = false;

                        let currentEligibleEmployees = workplaceObj.qualifiedAndAvailable.filter(emp => currentRoundEmployeePool.includes(emp));
                        
                        shuffleArray(currentEligibleEmployees); 

                        let optimalCandidates = [...currentEligibleEmployees].sort((a, b) => {
                            const a_consecutive_score = (employeeLastWorkplace[a] === currentWorkplace) ? 1 : 0;
                            const b_consecutive_score = (employeeLastWorkplace[b] === currentWorkplace) ? 1 : 0;
                            if (a_consecutive_score !== b_consecutive_score) {
                                return a_consecutive_score - b_consecutive_score;
                            }

                            const a_repeats = employeeWorkplaceCounts[a][currentWorkplace];
                            const b_repeats = employeeWorkplaceCounts[b][currentWorkplace];
                            if (a_repeats !== b_repeats) {
                                return a_repeats - b_repeats;
                            }
                            
                            if (i === 0 && previousDaySchedule) { 
                                const a_was_at_same_wp_prev_day = (previousDaySchedule[currentWorkplace] === a) ? 1 : 0;
                                const b_was_at_same_wp_prev_day = (previousDaySchedule[currentWorkplace] === b) ? 1 : 0;
                                if (a_was_at_same_wp_prev_day !== b_was_at_same_wp_prev_day) {
                                    return a_was_at_same_wp_prev_day - b_was_at_same_wp_prev_day;
                                }
                            }

                            const a_unique_workplaces = Object.values(employeeWorkplaceCounts[a]).filter(count => count > 0).length;
                            const b_unique_workplaces = Object.values(employeeWorkplaceCounts[b]).filter(count => count > 0).length;
                            return b_unique_workplaces - a_unique_workplaces; 
                        });

                        for (const emp of optimalCandidates) {
                            if (currentRoundEmployeePool.includes(emp)) { 
                                if (employeeWorkplaceCounts[emp][currentWorkplace] < maxWorkplaceRepeats) {
                                    rotationAssignments[currentWorkplace] = emp;
                                    currentRoundEmployeePool = currentRoundEmployeePool.filter(e => e !== emp); 
                                    employeeWorkplaceCounts[emp][currentWorkplace]++;
                                    employeeLastWorkplace[emp] = currentWorkplace;
                                    assigned = true;
                                    break;
                                } else {
                                    overallOptimalSchedule = false; 
                                }
                            }
                        }

                        if (!assigned) {
                            overallOptimalSchedule = false; 
                            for (const emp of currentEligibleEmployees) { 
                                if (currentRoundEmployeePool.includes(emp)) { 
                                    rotationAssignments[currentWorkplace] = emp;
                                    currentRoundEmployeePool = currentRoundEmployeePool.filter(e => e !== emp);
                                    employeeWorkplaceCounts[emp][currentWorkplace]++;
                                    employeeLastWorkplace[emp] = currentWorkplace;
                                    assigned = true;
                                    break;
                                }
                            }
                        }

                        if (!assigned) {
                            rotationAssignments[currentWorkplace] = 'UNPLANBAR';
                            displayMessage(`Kritischer Fehler: Arbeitsplatz "${currentWorkplace}" konnte nicht besetzt werden. Es gibt keine qualifizierten Mitarbeiter mehr, die in dieser Runde zugewiesen werden können.`, 'error');
                            overallOptimalSchedule = false;
                        }
                    }
                    allDailySchedules[dayOfWeek][currentRotation] = rotationAssignments;
                }

                saveData(); // Speichert das Ergebnis online
                if (startRotationIndex === 0) {
                    displayMessage('Schichtplan erfolgreich generiert und online gespeichert!', 'info');
                } else {
                    displayMessage(`Runden ${rotations[startRotationIndex]} bis ${rotations[rotations.length - 1]} neu generiert und gespeichert!`, 'info');
                }

                renderScheduleTable(dayOfWeek);
                document.getElementById('printScheduleBtn').style.display = 'block';

            } catch (error) {
                console.error("Fehler bei der Schichtplanerstellung:", error);
                displayMessage(`Ein unerwarteter Fehler ist aufgetreten: ${error.message}.`, 'error');
                document.getElementById('printScheduleBtn').style.display = 'none';
            }
        }

        function renderScheduleTable(day) {
            const scheduleOutputDiv = document.getElementById('scheduleOutput');
            scheduleOutputDiv.innerHTML = ''; 

            const header = document.createElement('h2');
            header.textContent = `Schichtplan für ${day}`;
            scheduleOutputDiv.appendChild(header);

            const table = document.createElement('table');
            table.className = 'schedule-table';
            const thead = document.createElement('thead');
            const tbody = document.createElement('tbody');

            let headerRow = document.createElement('tr');
            let thCorner = document.createElement('th');
            thCorner.textContent = 'Arbeitsplatz';
            headerRow.appendChild(thCorner);
            const rotations = ['1. Runde', '2. Runde', '3. Runde', '4. Runde'];
            rotations.forEach(round => {
                let th = document.createElement('th');
                th.textContent = round;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            workplaces.forEach(wp => {
                let row = document.createElement('tr');
                let tdWorkplace = document.createElement('td');
                tdWorkplace.textContent = wp;
                row.appendChild(tdWorkplace);

                rotations.forEach((rotation, index) => {
                    let td = document.createElement('td');
                    td.textContent = (allDailySchedules[day] && allDailySchedules[day][rotation] && allDailySchedules[day][rotation][wp]) || 'N/A';
                    td.setAttribute('contenteditable', 'true');
                    td.dataset.rotation = rotation;
                    td.dataset.workplace = wp;
                    td.dataset.day = day;

                    td.addEventListener('blur', function() {
                        const editedDay = this.dataset.day;
                        const editedRotation = this.dataset.rotation;
                        const editedWorkplace = this.dataset.workplace;
                        const newValue = this.textContent.trim();
                        
                        if (newValue !== '') {
                            allDailySchedules[editedDay][editedRotation][editedWorkplace] = newValue;
                            saveData();
                            displayMessage('Manuelle Änderung gespeichert!', 'info');
                            
                            const editedRotationIndex = rotations.indexOf(editedRotation);
                            if (editedRotationIndex < rotations.length -1) { 
                                generateSchedule(editedRotationIndex + 1); 
                            } else {
                                renderScheduleTable(document.getElementById('dayOfWeek').value);
                            }
                        } else {
                            this.textContent = 'N/A';
                            allDailySchedules[editedDay][editedRotation][editedWorkplace] = 'N/A';
                            saveData();
                            displayMessage('Manuelle Änderung gespeichert!', 'info');
                            const editedRotationIndex = rotations.indexOf(editedRotation);
                            if (editedRotationIndex < rotations.length -1) { 
                                generateSchedule(editedRotationIndex + 1); 
                            } else {
                                renderScheduleTable(document.getElementById('dayOfWeek').value);
                            }
                        }
                    });
                    row.appendChild(td);
                });
                tbody.appendChild(row);
            });
            table.appendChild(tbody);
            scheduleOutputDiv.appendChild(table);

            const allTds = document.querySelectorAll('.schedule-table td[data-day]');
            allTds.forEach(td => {
                const day = td.dataset.day;
                const rotation = td.dataset.rotation;
                const employeeName = td.textContent.trim();
                checkAndColorCell(td, employeeName, rotation, day);
            });
        }


        // --- Funktion zur Überprüfung und Einfärbung von Zellen ---
        function checkAndColorCell(cellElement, employeeName, rotation, day) {
            cellElement.classList.remove('error-duplicate', 'warn-skill', 'warn-unknown', 'auto-compromise');
            cellElement.style.backgroundColor = ''; 
            let cellWarnings = [];

            const workplace = cellElement.dataset.workplace;
            const currentRotationData = allDailySchedules[day][rotation];

            if (employeeName === 'UNPLANBAR') {
                cellWarnings.push('Konnte nicht automatisch geplant werden.');
                cellElement.classList.add('error-duplicate');
            } else if (employeeName === 'N/A') {
                // No special handling
            }
            else if (!employees.includes(employeeName)) {
                cellWarnings.push('Warnung: Mitarbeiter ist nicht registriert.');
                cellElement.classList.add('warn-unknown');
            }
            else if (employeeSkills[employeeName] && !employeeSkills[employeeName].includes(workplace)) {
                cellWarnings.push(`Warnung: ${employeeName} hat keine Fähigkeit für ${workplace}.`);
                cellElement.classList.add('warn-skill');
            }

            if (employeeName && employeeName !== 'N/A' && employeeName !== 'UNPLANBAR' && employees.includes(employeeName)) {
                let countInRotation = 0;
                for (const wpKey in currentRotationData) {
                    if (currentRotationData[wpKey] === employeeName) {
                        countInRotation++;
                    }
                }
                if (countInRotation > 1) {
                    cellWarnings.push(`Fehler: Dieser Mitarbeiter ist in dieser Runde mehrfach zugewiesen!`);
                    cellElement.classList.add('error-duplicate');
                }
            }

            for (const link of linkedWorkplaces) {
                const wp1 = link[0];
                const wp2 = link[1];

                if (workplace === wp1 || workplace === wp2) {
                    const emp1 = currentRotationData[wp1];
                    const emp2 = currentRotationData[wp2];

                    const areBothAssigned = (emp1 && emp1 !== 'N/A' && emp1 !== 'UNPLANBAR') && (emp2 && emp2 !== 'N/A' && emp2 !== 'UNPLANBAR');
                    const areBothUnassigned = (emp1 === 'N/A' || emp1 === 'UNPLANBAR') && (emp2 === 'N/A' || emp2 === 'UNPLANBAR');
                    const areSameEmployeeAtLinked = emp1 === emp2 && emp1 !== 'N/A' && emp1 !== 'UNPLANBAR';

                    if (!areBothAssigned && !areBothUnassigned) {
                        cellWarnings.push(`Warnung: Verknüpfte Arbeitsplätze ${wp1} und ${wp2} sind nicht korrekt zusammen besetzt.`);
                        cellElement.classList.add('warn-skill');
                    } else if (areSameEmployeeAtLinked) {
                        cellWarnings.push(`Fehler: Derselbe Mitarbeiter (${emp1}) an verknüpften Arbeitsplätzen ${wp1} und ${wp2}.`);
                        cellElement.classList.add('error-duplicate');
                    }
                }
            }
            
            cellElement.title = cellWarnings.join('\n');
            if (cellWarnings.length === 0) {
                cellElement.title = '';
            }
        }


        // --- Funktion zum Drucken des Schichtplans ---
        function printSchedule() {
            const scheduleOutputContent = document.getElementById('scheduleOutput').innerHTML;
            const dayOfWeek = document.getElementById('dayOfWeek').value;

            const printContent = `
                <html>
                <head>
                    <title>Schichtplan ${dayOfWeek}</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; }
                        h2 { color: #0056b3; text-align: center; margin-bottom: 20px;}
                        table { width: 100%; border-collapse: collapse; margin-top: 15px; }
                        th, td { border: 1px solid #ddd; padding: 10px; text-align: left; }
                        th { background-color: #e2f0ff; color: #0056b3; }
                        td { background-color: #fff; }
                        td[style*="background-color"] { -webkit-print-color-adjust: exact; color-adjust: exact; }
                        td.error-duplicate { background-color: #ff6666 !important; }
                        td.warn-skill { background-color: #ffaa00 !important; }
                        td.warn-unknown { background-color: #a0a0a0 !important; }
                        td.auto-compromise { background-color: #ffddaa !important; }
                        @page { margin: 1cm; }
                    </style>
                </head>
                <body>
                    ${scheduleOutputContent}
                </body>
                </html>
            `;

            const printWindow = window.open('', '_blank');
            printWindow.document.open();
            printWindow.document.write(printContent);
            printWindow.document.close();

            printWindow.onload = function() {
                printWindow.focus();
                printWindow.print();
            };
        }

        // --- Helper for displaying messages ---
        function displayMessage(message, type) {
            const errorMessageDiv = document.getElementById('errorMessage');
            const infoMessageDiv = document.getElementById('infoMessage');

            if (type === 'error') {
                errorMessageDiv.textContent = message;
                infoMessageDiv.textContent = '';
            } else if (type === 'info') {
                infoMessageDiv.textContent = message;
                errorMessageDiv.textContent = '';
            }
        }

        // Initialisierung: Daten beim Laden der Seite laden und UI aktualisieren
        document.addEventListener('DOMContentLoaded', () => {
            if(G_SCRIPT_URL === 'DEINE_APPS_SCRIPT_URL_HIER'){
                displayMessage('FEHLER: Bitte füge deine Google Apps Script URL in der HTML-Datei ein.', 'error');
                return;
            }
            loadData();
        });

        // --- Import/Export Funktionen ---
        function exportToJSON() {
            const dataToExport = {
                employees,
                workplaces,
                employeeSkills,
                allDailySchedules,
                linkedWorkplaces,
                employeePairs
            };

            const jsonStr = JSON.stringify(dataToExport, null, 2);
            const blob = new Blob([jsonStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.href = url;
            link.download = 'schichtplan-daten.json';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function importFromJSON(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    employees = importedData.employees || [];
                    workplaces = importedData.workplaces || [];
                    employeeSkills = importedData.employeeSkills || {};
                    allDailySchedules = importedData.allDailySchedules || {};
                    linkedWorkplaces = importedData.linkedWorkplaces || [];
                    employeePairs = importedData.employeePairs || [];

                    // UI aktualisieren UND direkt online speichern
                    saveData();
                    
                    renderEmployeeList();
                    renderWorkplaceList();
                    updateEmployeeSelects();
                    updateWorkplaceSelects();
                    updateLinkedWorkplaceSelects();
                    updateEmployeePairSelects();
                    updatePresentEmployeeCheckboxes();
                    renderLinkedWorkplaces();
                    renderEmployeePairs();

                    displayMessage('Daten erfolgreich importiert und online gespeichert.', 'info');
                } catch (error) {
                    displayMessage('Fehler beim Importieren der Datei: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        }
    </script>
</body>
</html>